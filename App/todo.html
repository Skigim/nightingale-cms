<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Private To-Do App</title>
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com https://unpkg.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src https://fonts.gstatic.com; connect-src 'self';"
    />

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Day.js for enhanced date management -->
    <script src="lib/dayjs.min.js"></script>
    <script src="lib/dayjs-relativeTime.min.js"></script>
    <script src="lib/dayjs-customParseFormat.min.js"></script>
    <script>
      // Initialize Day.js plugins
      if (typeof dayjs !== 'undefined') {
        dayjs.extend(window.dayjs_plugin_relativeTime);
        dayjs.extend(window.dayjs_plugin_customParseFormat);
      }
    </script>

    <script src="js/nightingale.utils.js"></script>
    <script src="js/nightingale.dayjs.js"></script>
    <script src="js/nightingale.parsers.js"></script>
    <script src="js/nightingale.fileservice.js"></script>
    <script src="js/nightingale.toast.js"></script>

    <!-- Lodash for reliable utility functions -->
    <script src="https://unpkg.com/lodash@4.17.21/lodash.min.js"></script>

    <script>
      // Basic Tailwind configuration
      tailwind.config = {
        darkMode: 'class',
      };
    </script>
    <style>
      /* Basic styling and animations for the app */
      body {
        font-family: sans-serif;
      }
      .dragging {
        opacity: 0.5;
        background: #f0f0f0;
        box-shadow:
          0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }
      .subtask-container {
        transition:
          max-height 0.3s ease-in-out,
          opacity 0.3s ease-in-out;
        max-height: 1000px; /* Set a large max-height for open state */
        opacity: 1;
        overflow: hidden;
      }
      .subtask-container.collapsed {
        max-height: 0;
        opacity: 0;
      }
      .toast {
        transition: all 0.3s ease-in-out;
        opacity: 0;
        transform: translateX(100%);
      }
      .toast.show {
        opacity: 1;
        transform: translateX(0);
      }
      .mcn-validation {
        display: inline-block;
        margin-left: 0.5rem;
        font-size: 0.8rem;
        font-weight: bold;
      }
      .mcn-valid {
        color: #16a34a;
      }
      .mcn-invalid {
        color: #dc2626;
      }
    </style>
  </head>
  <body class="bg-gray-50 dark:bg-gray-900">
    <div id="root"></div>
    <div id="toast-container" class="fixed bottom-6 right-6 z-[2000] flex flex-col gap-3"></div>

    <script type="text/javascript">
      const { useState, useEffect, useMemo, useRef, useCallback, memo } = React;

      const LOCAL_STORAGE_KEY_THEME = 'react-todo-app-theme';

      const channel = new BroadcastChannel('nightingale_suite');

      const TAB_ID = `todo-tab-${dayjs().valueOf()}-${Math.random()}`;

      /*
       * =============================================================================
       * FILE SYSTEM ACCESS API SERVICES (MODULAR VERSION)
       * =============================================================================
       * The FileSystemService class is now loaded from the shared nightingale.fileservice.js file.
       */

      // --- Custom Hooks ---
      function useLocalStorage(key, initialValue) {
        const [storedValue, setStoredValue] = useState(() => {
          try {
            const item = window.localStorage.getItem(key);
            if (item === null) return initialValue;
            try {
              return JSON.parse(item);
            } catch (e) {
              return item;
            }
          } catch (error) {
            console.log(error);
            return initialValue;
          }
        });

        const setValue = (value) => {
          try {
            const valueToStore = value instanceof Function ? value(storedValue) : value;
            setStoredValue(valueToStore);
            window.localStorage.setItem(key, JSON.stringify(valueToStore));
          } catch (error) {
            console.log(error);
          }
        };

        return [storedValue, setValue];
      }

      function useDragAndDrop(setTasks) {
        const dragItem = useRef(null);
        const dragOverItem = useRef(null);

        const handleDragEnd = useCallback(() => {
          dragItem.current = null;
          dragOverItem.current = null;
        }, []);

        const handleMainDrag = useCallback((e, taskId) => {
          dragItem.current = { id: taskId, type: 'main' };
          e.dataTransfer.effectAllowed = 'move';
        }, []);

        const handleSubtaskDrag = useCallback((e, taskId, subtaskId) => {
          dragItem.current = { taskId, subtaskId, type: 'subtask' };
          e.dataTransfer.effectAllowed = 'move';
        }, []);

        const handleMainDragOver = useCallback((e, taskId) => {
          e.preventDefault();
          if (dragItem.current?.type === 'main') {
            dragOverItem.current = { id: taskId };
          }
        }, []);

        const handleSubtaskDragOver = useCallback((e, taskId, subtaskId) => {
          e.preventDefault();
          e.stopPropagation();
          if (dragItem.current?.type === 'subtask') {
            dragOverItem.current = { taskId, subtaskId };
          }
        }, []);

        const handleMainDrop = useCallback(() => {
          const draggedItem = dragItem.current;
          const draggedOverItem = dragOverItem.current;

          if (
            !draggedItem ||
            draggedItem.type !== 'main' ||
            !draggedOverItem ||
            draggedItem.id === draggedOverItem.id
          ) {
            handleDragEnd();
            return;
          }

          setTasks((prevTasks) => {
            const newTasks = [...prevTasks];
            const draggedIndex = newTasks.findIndex((t) => t.id === draggedItem.id);
            const targetIndex = newTasks.findIndex((t) => t.id === draggedOverItem.id);

            if (draggedIndex === -1 || targetIndex === -1) return prevTasks;

            const [draggedItemContent] = newTasks.splice(draggedIndex, 1);
            newTasks.splice(targetIndex, 0, draggedItemContent);
            return newTasks;
          });
          handleDragEnd();
        }, [setTasks, handleDragEnd]);

        const handleSubtaskDrop = useCallback(() => {
          const draggedItem = dragItem.current;
          const draggedOverItem = dragOverItem.current;

          if (
            !draggedItem ||
            draggedItem.type !== 'subtask' ||
            !draggedOverItem ||
            !draggedOverItem.taskId ||
            draggedItem.taskId !== draggedOverItem.taskId ||
            draggedItem.subtaskId === draggedOverItem.subtaskId
          ) {
            handleDragEnd();
            return;
          }

          setTasks((prevTasks) => {
            const newTasks = [...prevTasks];
            const taskIndex = newTasks.findIndex((t) => t.id === draggedItem.taskId);
            if (taskIndex === -1) return prevTasks;

            const task = newTasks[taskIndex];
            const draggedSubtaskIndex = task.subtasks.findIndex((s) => s.id === draggedItem.subtaskId);
            const targetSubtaskIndex = task.subtasks.findIndex((s) => s.id === draggedOverItem.subtaskId);

            if (draggedSubtaskIndex === -1 || targetSubtaskIndex === -1) return prevTasks;

            const [draggedSubtask] = task.subtasks.splice(draggedSubtaskIndex, 1);
            task.subtasks.splice(targetSubtaskIndex, 0, draggedSubtask);
            return newTasks;
          });
          handleDragEnd();
        }, [setTasks, handleDragEnd]);

        return {
          handleMainDrag,
          handleSubtaskDrag,
          handleMainDrop,
          handleSubtaskDrop,
          handleMainDragOver,
          handleSubtaskDragOver,
          handleDragEnd,
        };
      }

      // --- Helper Icons (as React.createElement calls) ---
      const e = React.createElement;

      const SunIcon = () =>
        e(
          'svg',
          {
            xmlns: 'http://www.w3.org/2000/svg',
            width: '24',
            height: '24',
            viewBox: '0 0 24 24',
            fill: 'none',
            stroke: 'currentColor',
            strokeWidth: '2',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
          },
          e('circle', { cx: '12', cy: '12', r: '5' }),
          e('line', { x1: '12', y1: '1', x2: '12', y2: '3' }),
          e('line', { x1: '12', y1: '21', x2: '12', y2: '23' }),
          e('line', { x1: '4.22', y1: '4.22', x2: '5.64', y2: '5.64' }),
          e('line', { x1: '18.36', y1: '18.36', x2: '19.78', y2: '19.78' }),
          e('line', { x1: '1', y1: '12', x2: '3', y2: '12' }),
          e('line', { x1: '21', y1: '12', x2: '23', y2: '12' }),
          e('line', { x1: '4.22', y1: '19.78', x2: '5.64', y2: '18.36' }),
          e('line', { x1: '18.36', y1: '5.64', x2: '19.78', y2: '4.22' })
        );
      const MoonIcon = () =>
        e(
          'svg',
          {
            xmlns: 'http://www.w3.org/2000/svg',
            width: '24',
            height: '24',
            viewBox: '0 0 24 24',
            fill: 'none',
            stroke: 'currentColor',
            strokeWidth: '2',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
          },
          e('path', { d: 'M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z' })
        );
      const DragHandleIcon = () =>
        e(
          'svg',
          {
            xmlns: 'http://www.w3.org/2000/svg',
            width: '20',
            height: '20',
            viewBox: '0 0 24 24',
            fill: 'none',
            stroke: 'currentColor',
            strokeWidth: '2',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
            className: 'cursor-grab text-gray-400',
          },
          e('circle', { cx: '12', cy: '5', r: '1' }),
          e('circle', { cx: '12', cy: '12', r: '1' }),
          e('circle', { cx: '12', cy: '19', r: '1' })
        );
      const ChevronDownIcon = () =>
        e(
          'svg',
          {
            xmlns: 'http://www.w3.org/2000/svg',
            width: '20',
            height: '20',
            viewBox: '0 0 24 24',
            fill: 'none',
            stroke: 'currentColor',
            strokeWidth: '2',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
          },
          e('polyline', { points: '6 9 12 15 18 9' })
        );
      const NoteIcon = () =>
        e(
          'svg',
          {
            xmlns: 'http://www.w3.org/2000/svg',
            width: '16',
            height: '16',
            viewBox: '0 0 24 24',
            fill: 'none',
            stroke: 'currentColor',
            strokeWidth: '2',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
          },
          e('path', {
            d: 'M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z',
          }),
          e('polyline', { points: '13 2 13 9 20 9' })
        );
      const CopyIcon = () =>
        e(
          'svg',
          {
            xmlns: 'http://www.w3.org/2000/svg',
            width: '16',
            height: '16',
            viewBox: '0 0 24 24',
            fill: 'none',
            stroke: 'currentColor',
            strokeWidth: '2',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
          },
          e('rect', {
            x: '9',
            y: '9',
            width: '13',
            height: '13',
            rx: '2',
            ry: '2',
          }),
          e('path', {
            d: 'M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1',
          })
        );
      const BulkAddIcon = () =>
        e(
          'svg',
          {
            xmlns: 'http://www.w3.org/2000/svg',
            width: '16',
            height: '16',
            viewBox: '0 0 24 24',
            fill: 'none',
            stroke: 'currentColor',
            strokeWidth: '2',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
          },
          e('rect', {
            x: '3',
            y: '3',
            width: '18',
            height: '18',
            rx: '2',
            ry: '2',
          }),
          e('line', { x1: '12', y1: '8', x2: '12', y2: '16' }),
          e('line', { x1: '8', y1: '12', x2: '16', y2: '12' })
        );

      // --- Main App Component ---
      const ConfirmationModal = memo(({ isOpen, onCancel, onConfirm, title, children }) => {
        if (!isOpen) return null;
        return e(
          'div',
          {
            className: 'fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center',
            onClick: onCancel,
          },
          e(
            'div',
            {
              className: 'bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md',
              onClick: (ev) => ev.stopPropagation(),
            },
            e('h2', { className: 'text-xl font-bold mb-4' }, title),
            e('div', { className: 'text-gray-700 dark:text-gray-300 mb-6' }, children),
            e(
              'div',
              { className: 'flex justify-end space-x-4' },
              e(
                'button',
                {
                  onClick: onCancel,
                  className:
                    'px-4 py-2 rounded text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700',
                },
                'Cancel'
              ),
              e(
                'button',
                {
                  onClick: onConfirm,
                  className: 'px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700',
                },
                'Confirm'
              )
            )
          )
        );
      });

      function App() {
        const [globalError, setGlobalError] = useState(null);

        useEffect(() => {
          const handleError = (event) => {
            event.preventDefault();
            console.error('An unexpected global error occurred:', event.error);
            setGlobalError('A critical error occurred. Please refresh the page. Details are in the console.');
          };
          window.addEventListener('error', handleError);
          return () => {
            window.removeEventListener('error', handleError);
          };
        }, []);

        const [fullData, setFullData] = useState({
          todos: [],
          cases: [],
          nextNoteId: 1,
        });
        const { todos: tasks, cases: cmsCases, nextNoteId } = fullData;

        const [newTask, setNewTask] = useState('');
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [filter, setFilter] = useState('active');
        const [theme, setTheme] = useLocalStorage(LOCAL_STORAGE_KEY_THEME, 'light');
        const [modalState, setModalState] = useState({ type: 'closed' });
        const [confirmationModal, setConfirmationModal] = useState({
          isOpen: false,
        });
        const [hasFSAccess, setHasFSAccess] = useState(false);
        const [permissionStatus, setPermissionStatus] = useState('checking');

        const fileService = useMemo(
          () =>
            new FileSystemService({
              tabId: TAB_ID,
              errorCallback: showToast,
              sanitizeFn: sanitize,
            }),
          []
        );
        // The workLogService has been removed. The main fileService now handles all operations.
        const isInitialLoad = useRef(true);
        const isRefreshing = useRef(false); // New flag to prevent refresh loops
        const hasFSAccessRef = useRef(hasFSAccess);
        const debounceTimeoutRef = useRef(null); // Ref to hold the debounce timer
        useEffect(() => {
          hasFSAccessRef.current = hasFSAccess;
        }, [hasFSAccess]);
        const latestDataRef = useRef(fullData);

        useEffect(() => {
          latestDataRef.current = fullData;
        }, [fullData]);

        const updateAndSave = useCallback(
          (updater) => {
            setFullData((prevData) => {
              const newData = typeof updater === 'function' ? updater(prevData) : prevData;

              if (!isInitialLoad.current && hasFSAccessRef.current && !isRefreshing.current) {
                // Clear any existing save timeout to debounce
                clearTimeout(debounceTimeoutRef.current);

                // Set a new timeout to save the data after a short delay
                debounceTimeoutRef.current = setTimeout(() => {
                  console.log('To-Do App: Debounced save triggered.', {
                    timestamp: dateUtils.format(dateUtils.now(), 'HH:mm:ss'),
                  });
                  fileService.writeFile(newData);
                }, 150); // A 150ms debounce period is a safe starting point
              } else {
                console.log('Save skipped.', {
                  isInitial: isInitialLoad.current,
                  hasAccess: hasFSAccessRef.current,
                  isRefreshing: isRefreshing.current,
                });
              }

              return newData;
            });
          },
          [fileService]
        );

        const setTasks = useCallback(
          (tasksUpdater) => {
            updateAndSave((prevData) => ({
              ...prevData,
              todos: tasksUpdater(prevData.todos),
            }));
          },
          [updateAndSave]
        );

        const dragAndDrop = useDragAndDrop(setTasks);

        useEffect(() => {
          const autoConnect = async () => {
            const { handle, permission } = await fileService.restoreLastDirectoryAccess();
            if (handle) {
              setPermissionStatus(permission);
              if (permission === 'granted') {
                await loadTasksAfterPermission();
              }
            } else {
              setHasFSAccess(false);
            }
            isInitialLoad.current = false;
            setLoading(false);
          };
          autoConnect();
        }, [fileService]);

        useEffect(() => {
          document.documentElement.classList.toggle('dark', theme === 'dark');
        }, [theme]);

        const loadTasksAfterPermission = useCallback(async () => {
          setLoading(true);
          setError(null);

          const loadedData = await fileService.readFile();
          const defaultData = { todos: [], cases: [], nextNoteId: 1 };
          const initialData = { ...defaultData, ...(loadedData || {}) };

          // This is the fix: Explicitly set the state and then ensure the file exists.
          setFullData(initialData);
          setHasFSAccess(true);
          setPermissionStatus('granted');
          setLoading(false);

          // If no data was loaded, it means the file didn't exist.
          // We'll perform one explicit save to create it.
          if (!loadedData) {
            console.log('No data file found. Creating initial file.');
            await fileService.writeFile(initialData);
          }
        }, [fileService, setFullData]);

        const refreshDataSilently = useCallback(async () => {
          if (!hasFSAccess || isRefreshing.current) return;

          isRefreshing.current = true; // Set the flag to prevent saves
          try {
            const loadedData = await fileService.readFile();
            if (!loadedData) return;

            setFullData((currentData) => {
              const mergedData = { ...currentData, ...loadedData };

              if (currentData.todos && loadedData.todos) {
                const todoMap = new Map(currentData.todos.map((item) => [item.id, item]));
                loadedData.todos.forEach((item) => todoMap.set(item.id, item));
                mergedData.todos = Array.from(todoMap.values());
              }

              if (JSON.stringify(currentData) !== JSON.stringify(mergedData)) {
                console.log('To-Do App: Data changed, refreshing silently.');
                return mergedData;
              }
              return currentData;
            });
          } catch (error) {
            console.error('Silent refresh failed:', error);
          } finally {
            isRefreshing.current = false; // Always release the flag
          }
        }, [fileService, hasFSAccess, setFullData]);

        useEffect(() => {
          const handleFocus = () => {
            if (hasFSAccess && !isInitialLoad.current) {
              refreshDataSilently();
            }
          };
          const handleVisibilityChange = () => {
            if (document.visibilityState === 'visible') {
              handleFocus();
            }
          };

          const handleStorageChange = (e) => {
            if (e.key === 'nightingale-last-save' && e.newValue) {
              try {
                const { tabId } = JSON.parse(e.newValue);
                if (tabId !== TAB_ID) {
                  console.log('To-Do App: Received save event from another tab. Refreshing.');
                  const randomDelay = Math.random() * 200 + 100; // Delay between 100ms and 300ms
                  setTimeout(() => refreshDataSilently(), randomDelay);
                }
              } catch (err) {
                console.error('Could not parse storage event:', err);
              }
            }
          };

          // Listen for command messages from other apps
          const handleChannelMessage = (e) => {
            if (e.data?.type === 'case_created') {
              console.log('To-Do App: Received case creation confirmation. Refreshing data.');
              setTimeout(() => refreshDataSilently(), 250);
            }
          };

          window.addEventListener('focus', handleFocus);
          document.addEventListener('visibilitychange', handleVisibilityChange);
          window.addEventListener('storage', handleStorageChange);
          channel.addEventListener('message', handleChannelMessage);

          return () => {
            window.removeEventListener('focus', handleFocus);
            document.removeEventListener('visibilitychange', handleVisibilityChange);
            window.removeEventListener('storage', handleStorageChange);
            channel.removeEventListener('message', handleChannelMessage);
          };
        }, [hasFSAccess, refreshDataSilently]);

        const handleSelectFolder = useCallback(async () => {
          const accessGranted = await fileService.connect();
          if (accessGranted) {
            await loadTasksAfterPermission();
          }
        }, [fileService, loadTasksAfterPermission]);

        const handleGrantPermission = useCallback(async () => {
          const accessGranted = await fileService.requestPermission();
          if (accessGranted) {
            await loadTasksAfterPermission();
          } else {
            setPermissionStatus('denied');
          }
        }, [fileService, loadTasksAfterPermission]);

        const updateTaskProperty = useCallback((taskId, property, value, subtaskId = null) => {
          setTasks((prev) =>
            prev.map((task) => {
              if (task.id === taskId) {
                if (subtaskId && task.type === 'multi') {
                  const subtasks = task.subtasks.map((sub) =>
                    sub.id === subtaskId ? { ...sub, [property]: value } : sub
                  );
                  return { ...task, subtasks };
                }
                return { ...task, [property]: value };
              }
              return task;
            })
          );
        }, []);

        const onAddTasksInBulk = useCallback(
          (text) => {
            const lines = text.split('\n').filter((line) => line.trim() !== '');
            const uniqueEntries = {};

            lines.forEach((line) => {
              const parts = line.split('\t');
              if (parts.length >= 2) {
                const id = parts[0].trim();
                const rawName = parts[1].trim();
                const uniqueKey = `${id}-${rawName}`;

                if (!uniqueEntries[uniqueKey]) {
                  let formattedName = rawName.trim();
                  // If the name is in "Last, First" format, reorder it. Otherwise, use as-is.
                  if (formattedName.includes(',')) {
                    const nameParts = formattedName.split(',').map((p) => p.trim());
                    if (nameParts.length > 1) {
                      formattedName = `${nameParts[1]} ${nameParts[0]}`;
                    }
                  }

                  uniqueEntries[uniqueKey] = {
                    id: crypto.randomUUID(),
                    text: `${id} - ${formattedName}`,
                    createdAt: dateUtils.now(),
                    type: 'single',
                    completed: false,
                    notes: '',
                  };
                }
              }
            });

            const newTasks = Object.values(uniqueEntries);
            if (newTasks.length > 0) {
              setTasks((prev) => [...prev, ...newTasks]);
              showToast(`${newTasks.length} tasks added in bulk.`, 'success');
            }
          },
          [setTasks]
        );

        const onAddTask = useCallback(
          (e) => {
            e.preventDefault();
            if (newTask.trim() === '') return;
            const taskObject = {
              id: crypto.randomUUID(),
              text: newTask.trim(),
              createdAt: dateUtils.now(),
              type: 'single',
              completed: false,
              notes: '',
            };

            setTasks((prev) => [...prev, taskObject]);
            setNewTask('');
          },
          [newTask, setTasks]
        );

        const onConvertToMulti = useCallback((taskId) => {
          setTasks((prev) =>
            prev.map((task) => {
              if (task.id === taskId) {
                const { completed, ...rest } = task;
                return {
                  ...rest,
                  type: 'multi',
                  subtasks: [],
                  isCollapsed: false,
                  notes: task.notes || '',
                };
              }
              return task;
            })
          );
        }, []);

        const onAddSubtask = useCallback((taskId, subtaskText) => {
          if (subtaskText.trim() === '') return;
          const newSubtask = {
            id: crypto.randomUUID(),
            text: subtaskText.trim(),
            completed: false,
            notes: '',
          };
          setTasks((prev) =>
            prev.map((task) => (task.id === taskId ? { ...task, subtasks: [...task.subtasks, newSubtask] } : task))
          );
        }, []);

        const onAddSubtasksInBulk = useCallback((taskId, text) => {
          const lines = text.split('\n').filter((line) => line.trim() !== '');
          const uniqueEntries = {};
          lines.forEach((line) => {
            const parts = line.split('\t');
            if (parts.length >= 2) {
              const id = parts[0].trim();
              const rawName = parts[1].trim();
              const uniqueKey = `${id}-${rawName}`;
              if (!uniqueEntries[uniqueKey]) {
                let formattedName = rawName.trim();
                // If the name is in "Last, First" format, reorder it. Otherwise, use as-is.
                if (formattedName.includes(',')) {
                  const nameParts = formattedName.split(',').map((p) => p.trim());
                  if (nameParts.length > 1) {
                    formattedName = `${nameParts[1]} ${nameParts[0]}`;
                  }
                }
                uniqueEntries[uniqueKey] = {
                  id: crypto.randomUUID(),
                  text: `${id} - ${formattedName}`,
                  completed: false,
                  notes: '',
                };
              }
            }
          });
          const newSubtasks = Object.values(uniqueEntries);
          setTasks((prev) =>
            prev.map((task) => (task.id === taskId ? { ...task, subtasks: [...task.subtasks, ...newSubtasks] } : task))
          );
        }, []);

        const onSaveNote = useCallback(
          (task, subtaskId, category, note, timeSpent) => {
            // This function is now just for non-completion edits.
            // We can use the main `updateAndSave` function for a cleaner update.
            updateAndSave((prevData) => {
              const newTodos = prevData.todos.map((t) => {
                if (t.id === task.id) {
                  // Logic for updating the correct task or subtask
                  if (subtaskId && t.type === 'multi') {
                    const newSubtasks = t.subtasks.map((sub) => {
                      if (sub.id === subtaskId) {
                        return {
                          ...sub,
                          notes: note,
                          completionCategory: category,
                          timeSpent: parseInt(timeSpent, 10) || sub.timeSpent || 0,
                        };
                      }
                      return sub;
                    });
                    return { ...t, subtasks: newSubtasks };
                  } else {
                    return {
                      ...t,
                      notes: note,
                      completionCategory: category,
                      timeSpent: parseInt(timeSpent, 10) || t.timeSpent || 0,
                    };
                  }
                }
                return t;
              });
              return { ...prevData, todos: newTodos };
            });

            setModalState({ type: 'closed' });
          },
          [updateAndSave]
        );

        const onSaveCompletionNote = useCallback(
          (category, note, timeSpent) => {
            const { task, subtaskId } = modalState.props;
            let currentTaskOrSubtask = task;
            if (subtaskId) {
              currentTaskOrSubtask = task.subtasks.find((s) => s.id === subtaskId);
            }

            // We use the updater function of our new save mechanism,
            // so we don't need to rely on the ref here.
            updateAndSave((prevData) => {
              const MCN_REGEX = /\b\d{5,}\b/;
              const textSource = currentTaskOrSubtask.text;
              const mcnMatch = textSource.match(MCN_REGEX);
              const cmsNoteIdToUpdate = currentTaskOrSubtask.cmsNoteId;

              let newNextNoteId = prevData.nextNoteId;
              let newCases = [...(prevData.cases || [])];
              let newCmsNoteId = cmsNoteIdToUpdate;

              if (mcnMatch) {
                const matchedMcn = mcnMatch[0].toUpperCase();
                const caseIndex = newCases.findIndex(
                  (c) => c.masterCaseNumber && c.masterCaseNumber.toUpperCase() === matchedMcn
                );

                if (caseIndex > -1) {
                  const targetCase = { ...newCases[caseIndex] };
                  targetCase.notes = [...(targetCase.notes || [])];

                  if (cmsNoteIdToUpdate) {
                    const noteIndex = targetCase.notes.findIndex((n) => n.id === cmsNoteIdToUpdate);
                    if (noteIndex > -1) {
                      targetCase.notes[noteIndex] = {
                        ...targetCase.notes[noteIndex],
                        category,
                        text: note,
                      };
                    }
                  } else {
                    const newNote = {
                      id: newNextNoteId,
                      category: category || 'To-Do Completion',
                      text: note,
                      timestamp: dateUtils.now(),
                    };
                    targetCase.notes.push(newNote);
                    newCmsNoteId = newNextNoteId;
                    newNextNoteId++;
                  }
                  newCases[caseIndex] = targetCase;
                }
              }

              const newTodos = prevData.todos.map((t) => {
                if (t.id === task.id) {
                  if (subtaskId && t.type === 'multi') {
                    const newSubtasks = t.subtasks.map((sub) => {
                      if (sub.id === subtaskId) {
                        return {
                          ...sub,
                          completed: true,
                          notes: note,
                          completionCategory: category,
                          cmsNoteId: newCmsNoteId,
                          timeSpent: parseInt(timeSpent, 10) || 0,
                        };
                      }
                      return sub;
                    });
                    return { ...t, subtasks: newSubtasks };
                  } else if (!subtaskId && t.type === 'single') {
                    return {
                      ...t,
                      completed: true,
                      notes: note,
                      completionCategory: category,
                      cmsNoteId: newCmsNoteId,
                      timeSpent: parseInt(timeSpent, 10) || 0,
                    };
                  }
                }
                return t;
              });

              // Return the final, updated state object
              return {
                ...prevData,
                todos: newTodos,
                cases: newCases,
                nextNoteId: newNextNoteId,
              };
            });

            setModalState({ type: 'closed' });
          },
          [modalState.props, updateAndSave]
        );

        const onDelete = useCallback((taskId, subtaskId = null) => {
          if (subtaskId) {
            setTasks((prev) =>
              prev.map((task) =>
                task.id === taskId
                  ? {
                      ...task,
                      subtasks: task.subtasks.filter((sub) => sub.id !== subtaskId),
                    }
                  : task
              )
            );
          } else {
            setTasks((prev) => prev.filter((task) => task.id !== taskId));
          }
        }, []);

        const onClearCompleted = useCallback(() => {
          setTasks((prev) =>
            prev
              .map((task) => {
                if (task.type === 'single' && task.completed) return null;
                if (task.type === 'multi') {
                  const activeSubtasks = task.subtasks.filter((sub) => !sub.completed);
                  if (activeSubtasks.length === 0 && task.subtasks.length > 0) return null;
                  return { ...task, subtasks: activeSubtasks };
                }
                return task;
              })
              .filter(Boolean)
          );
        }, []);

        const onToggleCollapse = useCallback(
          (taskId) => {
            const task = tasks.find((t) => t.id === taskId);
            if (task) updateTaskProperty(taskId, 'isCollapsed', !task.isCollapsed);
          },
          [tasks, updateTaskProperty]
        );

        const onUncompleteTask = useCallback((taskId, subtaskId = null) => {
          setTasks((prev) =>
            prev.map((task) => {
              if (task.id === taskId) {
                if (subtaskId && task.type === 'multi') {
                  const subtasks = task.subtasks.map((sub) =>
                    sub.id === subtaskId
                      ? {
                          ...sub,
                          completed: false,
                          notes: '',
                          completionCategory: '',
                          cmsNoteId: null,
                        }
                      : sub
                  );
                  return { ...task, subtasks };
                }
                return {
                  ...task,
                  completed: false,
                  notes: '',
                  completionCategory: '',
                  cmsNoteId: null,
                };
              }
              return task;
            })
          );
        }, []);

        const onToggleComplete = useCallback(
          (task, subtaskId) =>
            setModalState({
              type: 'note',
              props: { task, subtaskId, isCompletion: true },
            }),
          []
        );
        const onOpenNotes = useCallback(
          (task, subtaskId) =>
            setModalState({
              type: 'note',
              props: { task, subtaskId, isCompletion: false },
            }),
          []
        );
        const onOpenBulkAdd = useCallback((task) => setModalState({ type: 'bulkAdd', props: { task } }), []);
        const onOpenBulkAddSingle = useCallback(() => setModalState({ type: 'bulkAddSingle' }), []);

        // MCN Validation utilities
        const validateMCN = useCallback(
          (text) => {
            // Step 1: Basic text parsing to find a potential MCN.
            // This is kept from the original to extract the MCN from a larger string like "12345 - John Doe".
            const mcnMatch = text ? text.match(/\b([A-Z0-9\-_]{3,})\b/i) : null;
            if (!mcnMatch) {
              return { isValid: false, mcn: null, case: null, suggestions: [] };
            }
            const potentialMcn = mcnMatch[0];

            // Step 2: Use the standardized Validator from utils.js to check the format.
            const validationResult = Validators.mcn()(potentialMcn);
            if (!validationResult.isValid) {
              // The format itself is invalid, so no need to check for existence.
              return {
                isValid: false,
                mcn: potentialMcn,
                case: null,
                suggestions: [],
              };
            }

            // Step 3: Check for the case's existence, now that we have a validly formatted MCN.
            // DEFENSIVE CHECK: Ensure cmsCases is a usable array.
            if (!cmsCases || !Array.isArray(cmsCases)) {
              return {
                isValid: false,
                mcn: validationResult.sanitizedValue,
                case: null,
                suggestions: [],
              };
            }

            const sanitizedMcn = validationResult.sanitizedValue;
            const matchingCase = cmsCases.find(
              (c) => c.masterCaseNumber && c.masterCaseNumber.toString() === sanitizedMcn
            );

            if (matchingCase) {
              return {
                isValid: true,
                mcn: sanitizedMcn,
                case: matchingCase,
                suggestions: [],
              };
            }

            // Step 4: If no match, generate suggestions (logic retained from original).
            const suggestions = cmsCases
              .filter((c) => c.masterCaseNumber)
              .map((c) => c.masterCaseNumber.toString())
              .filter((caseMcn) => {
                if (caseMcn.length !== sanitizedMcn.length) return false;
                let diffCount = 0;
                for (let i = 0; i < sanitizedMcn.length; i++) {
                  if (sanitizedMcn[i] !== caseMcn[i]) diffCount++;
                }
                return diffCount <= 2;
              })
              .slice(0, 3);

            return {
              isValid: false,
              mcn: sanitizedMcn,
              case: null,
              suggestions,
            };
          },
          [cmsCases]
        );

        const handleCaseLinkClick = useCallback(
          (e, text) => {
            e.preventDefault();
            const validation = validateMCN(text);
            const mcn = validation.mcn;

            if (!mcn) return;

            navigator.clipboard.writeText(mcn).then(
              () => {
                showToast(`MCN ${mcn} copied to clipboard.`, 'success');
              },
              () => {
                showToast('Failed to copy MCN.', 'error');
              }
            );

            if (validation.isValid) {
              let fallbackTimeout;
              const acknowledgementListener = (event) => {
                if (event.data.type === 'case_shown' && event.data.mcn === mcn) {
                  clearTimeout(fallbackTimeout);
                  channel.removeEventListener('message', acknowledgementListener);
                }
              };
              channel.addEventListener('message', acknowledgementListener);
              channel.postMessage({ type: 'show_case', mcn });
              fallbackTimeout = setTimeout(() => {
                window.open(`NightingaleCMS.html?mcn=${encodeURL(mcn)}`, '_blank');
                channel.removeEventListener('message', acknowledgementListener);
              }, 300);
            } else {
              // Case does NOT exist, ask user for confirmation to create it.
              const nameMatch = text.match(/\d{5,}\s*-\s*(.*)/);
              const name = nameMatch && nameMatch[1] ? nameMatch[1].trim() : null;

              if (name) {
                setConfirmationModal({
                  isOpen: true,
                  title: 'Create New Case?',
                  children: `Case with MCN "${mcn}" does not exist. Would you like to create a new placeholder case for "${name}"?`,
                  onConfirm: () => {
                    showToast(`Asking CMS to create placeholder for ${name}...`, 'info');
                    channel.postMessage({ type: 'create_case', mcn, name });
                    setConfirmationModal({ isOpen: false });
                  },
                  onCancel: () => setConfirmationModal({ isOpen: false }),
                });
              } else {
                showToast(`Case not found. Could not parse name from task to create placeholder.`, 'error');
              }
            }
          },
          [validateMCN]
        );

        const taskHandlers = useMemo(
          () => ({
            onUpdate: updateTaskProperty,
            onAddTask,
            onConvertToMulti,
            onAddSubtask,
            onAddSubtasksInBulk,
            onSaveCompletionNote,
            onDelete,
            onClearCompleted,
            onToggleCollapse,
            onToggleComplete,
            onUncompleteTask,
            onOpenNotes,
            onOpenBulkAdd,
            onOpenBulkAddSingle,
            validateMCN,
            handleCaseLinkClick, // Pass the new handler down
          }),
          [
            updateTaskProperty,
            onAddTask,
            onConvertToMulti,
            onAddSubtask,
            onAddSubtasksInBulk,
            onSaveCompletionNote,
            onDelete,
            onClearCompleted,
            onToggleCollapse,
            onToggleComplete,
            onUncompleteTask,
            onOpenNotes,
            onOpenBulkAdd,
            validateMCN,
            handleCaseLinkClick, // Add to dependency array
          ]
        );

        const handleGenerateLog = useCallback(() => {
          const today = dateUtils.formatToday('M/D/YYYY');
          const startTime = '08:00 AM';
          const endTime = '05:00 PM';

          let logEntries = [];
          let totalTimeSpent = 0;

          const logHeader = `Daily Work Log - ${today}
Start Time: ${startTime}
End Time: ${endTime}

SUMMARY OF ACTIVITIES:`;

          const multiTasksToLog = tasks.filter(
            (task) => task.type === 'multi' && task.subtasks.some((sub) => sub.completed)
          );

          if (multiTasksToLog.length > 0) {
            multiTasksToLog.forEach((task) => {
              const completedSubtasks = task.subtasks.filter((sub) => sub.completed);

              const categoryTitle = `CATEGORY: ${task.text.toUpperCase()}`;
              const separator = '='.repeat(categoryTitle.length);
              const categoryHeader = `\n${separator}\n${categoryTitle}\n${separator}`;

              let caseEntries = completedSubtasks
                .map((sub, index) => {
                  const caseTime = sub.timeSpent || 15;
                  totalTimeSpent += caseTime;

                  return `${sub.text}
   Action Taken: ${sub.notes || 'Completed review and update'}
   Time Spent: ${caseTime} minutes`;
                })
                .join('\n\n');

              logEntries.push(`${categoryHeader}\n${caseEntries}`);
            });
          }

          const logFooter = `\n${'='.repeat(50)}
TIME SUMMARY:
Total Documented Time: ${Math.floor(totalTimeSpent / 60)}h ${totalTimeSpent % 60}m
Tasks Completed: ${tasks
            .filter((t) => t.type === 'multi')
            .reduce((acc, t) => acc + t.subtasks.filter((s) => s.completed).length, 0)}

Log Created: ${dateUtils.formatToday('M/D/YYYY h:mm A')}
`;

          const finalLogContent = `${logHeader}\n${logEntries.join('\n\n')}${logFooter}`;

          setModalState({
            type: 'log',
            props: { textContent: finalLogContent },
          });
        }, [tasks]);

        const onGenerateOldestTasks = useCallback(async () => {
          // Use the special method to read the entire data file
          const allData = await fileService._readFullFile();

          if (!allData || !allData.cases || !Array.isArray(allData.cases)) {
            setError('Could not find valid case data to generate tasks.');
            return;
          }

          const PENDING_STATUSES = ['AVS Pending', 'VR Pending'];

          const pendingCases = allData.cases.filter((caseData) => PENDING_STATUSES.includes(caseData.status));

          if (pendingCases.length === 0) {
            alert('No pending cases found.'); // Simple alert for immediate feedback
            return;
          }

          pendingCases.sort((a, b) => {
            const dateA = new Date(a.appDetails?.appDate || 0);
            const dateB = new Date(b.appDetails?.appDate || 0);
            return dateA - dateB; // Sorts oldest to newest
          });

          const oldestFive = pendingCases.slice(0, 5);

          const newSubtasks = oldestFive.map((caseData) => {
            const person = (allData.people || []).find((p) => p.id === caseData.personId);
            const caseName = person ? person.name : caseData.name || 'Unknown';
            const subtaskText = `${caseData.masterCaseNumber || 'MCN?'} - ${caseName}`;

            return {
              id: crypto.randomUUID(),
              text: subtaskText,
              completed: false,
              notes: `Auto-generated from case data.\nApp Date: ${caseData.appDetails?.appDate || 'N/A'}`,
            };
          });

          const newMultiTask = {
            id: crypto.randomUUID(),
            text: 'OLDEST PENDING',
            createdAt: dateUtils.now(),
            type: 'multi',
            subtasks: newSubtasks,
            isCollapsed: false,
            notes: 'Auto-generated list of the 5 oldest pending cases.',
          };

          setTasks((prevTasks) => [...prevTasks, newMultiTask]);
        }, [fileService, setError]);

        const filteredTasks = useMemo(
          () =>
            tasks.filter((task) => {
              const isComplete =
                task.type === 'single'
                  ? task.completed
                  : task.subtasks.length > 0 && task.subtasks.every((s) => s.completed);
              if (filter === 'active') return !isComplete;
              if (filter === 'completed') return isComplete;
              return true;
            }),
          [tasks, filter]
        );

        const activeTasksCount = useMemo(
          () =>
            tasks.reduce((count, task) => {
              const isComplete =
                task.type === 'single'
                  ? task.completed
                  : task.subtasks.length > 0 && task.subtasks.every((s) => s.completed);
              return isComplete ? count : count + 1;
            }, 0),
          [tasks]
        );

        const renderContent = () => {
          if (!hasFSAccess) {
            return e(
              'div',
              {
                className: 'text-center p-10 bg-white dark:bg-gray-800 rounded-xl shadow-lg',
              },
              e('h2', { className: 'text-2xl font-bold mb-4' }, 'Connect to a Folder'),
              e(
                'p',
                { className: 'mb-6 text-gray-600 dark:text-gray-400' },
                'To save and load your tasks, please select a folder on your computer.'
              ),
              e(
                'button',
                {
                  onClick: handleSelectFolder,
                  className: 'px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700',
                },
                'Connect'
              )
            );
          }

          if (permissionStatus === 'prompt' || permissionStatus === 'denied') {
            return e(
              'div',
              {
                className:
                  'text-center p-10 bg-yellow-100 dark:bg-yellow-900 border border-yellow-400 dark:border-yellow-600 rounded-xl shadow-lg',
              },
              e('h2', { className: 'text-2xl font-bold mb-4' }, 'Permission Required'),
              e(
                'p',
                { className: 'mb-6 text-yellow-800 dark:text-yellow-200' },
                'This app needs access to its folder to load your tasks. Please grant permission to continue.'
              ),
              e(
                'button',
                {
                  onClick: handleGrantPermission,
                  className: 'px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700',
                },
                'Grant Access'
              ),
              permissionStatus === 'denied' &&
                e(
                  'p',
                  { className: 'mt-4 text-red-600 dark:text-red-400' },
                  "Permission was denied. You may need to grant access via your browser's site settings."
                )
            );
          }

          return e(
            React.Fragment,
            null,
            e(
              'div',
              {
                className: 'bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8',
              },
              e(
                'form',
                { onSubmit: taskHandlers.onAddTask },
                e(
                  'div',
                  { className: 'relative group' },
                  e('input', {
                    type: 'text',
                    value: newTask,
                    onChange: (ev) => setNewTask(ev.target.value),
                    placeholder: 'What needs to be done?',
                    className:
                      'w-full pl-4 pr-12 py-3 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500',
                  }),
                  e(
                    'button',
                    {
                      type: 'button',
                      onClick: taskHandlers.onOpenBulkAddSingle,
                      className:
                        'absolute right-3 top-1/2 -translate-y-1/2 p-1.5 rounded-full text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 opacity-0 group-hover:opacity-100 transition-opacity',
                      title: 'Bulk Add Tasks',
                    },
                    e(BulkAddIcon)
                  )
                )
              )
            ),
            e(
              'div',
              { className: 'space-y-4' },
              filteredTasks.map((task, index) =>
                e(TaskItem, {
                  key: task.id,
                  task: task,
                  handlers: taskHandlers,
                  dragAndDrop: dragAndDrop,
                })
              )
            ),
            tasks.length === 0 &&
              e('p', { className: 'text-center text-gray-500 py-4' }, 'Your list is empty! Add a task to get started.'),
            e(Footer, {
              activeTasksCount: activeTasksCount,
              filter: filter,
              setFilter: setFilter,
              onClearCompleted: taskHandlers.onClearCompleted,
              handleSelectFolder: handleSelectFolder,
              handleGenerateLog: handleGenerateLog,
              onGenerateOldestTasks: onGenerateOldestTasks,
            })
          );
        };

        const renderModal = () => {
          if (modalState.type === 'closed' && !confirmationModal.isOpen) return null;

          if (confirmationModal.isOpen) {
            return e(ConfirmationModal, { ...confirmationModal });
          }

          switch (modalState.type) {
            case 'note':
              const { task, subtaskId } = modalState.props;
              const subtask = task?.type === 'multi' && task.subtasks.find((s) => s.id === subtaskId);
              const currentItem = subtask || task;

              const initialNote = currentItem?.notes;
              const initialCategory = currentItem?.completionCategory;
              const isAlreadyComplete = currentItem?.completed;
              const initialTimeSpent = currentItem?.timeSpent;

              return e(CmsNoteModal, {
                isOpen: true,
                onClose: () => setModalState({ type: 'closed' }),
                onSave: modalState.props.isCompletion
                  ? onSaveCompletionNote
                  : (category, note, timeSpent) => {
                      onSaveNote(task, subtaskId, category, note, timeSpent);
                    },
                initialNote: initialNote || '',
                initialCategory: initialCategory || '',
                initialTimeSpent: initialTimeSpent || '',
                isCompletion: modalState.props.isCompletion,
                isAlreadyComplete: isAlreadyComplete,
                cases: cmsCases || [],
              });

            case 'log':
              return e(WorkLogModal, {
                isOpen: true,
                onClose: () => setModalState({ type: 'closed' }),
                textContent: modalState.props.textContent,
                fileService: fileService,
              });

            case 'bulkAdd':
              return e(BulkAddModal, {
                isOpen: true,
                onClose: () => setModalState({ type: 'closed' }),
                onSave: (text) => onAddSubtasksInBulk(modalState.props.task.id, text),
              });

            case 'bulkAddSingle':
              return e(BulkAddModal, {
                isOpen: true,
                onClose: () => setModalState({ type: 'closed' }),
                onSave: onAddTasksInBulk,
              });

            default:
              return null;
          }
        };

        if (loading)
          return e(
            'div',
            { className: 'flex items-center justify-center h-screen' },
            e('p', null, 'Checking for folder access...')
          );

        return e(
          'div',
          {
            className: 'min-h-screen font-sans text-gray-800 dark:text-gray-200',
          },
          renderModal(),
          e(
            'div',
            { className: 'container mx-auto p-4 sm:p-6 lg:p-8 max-w-3xl' },
            e(Header, { theme: theme, setTheme: setTheme }),
            error &&
              e(
                'p',
                {
                  className: 'text-red-500 bg-red-100 p-3 rounded-md mb-4',
                  onClick: () => setError(null),
                },
                error
              ),
            globalError &&
              e(
                'div',
                {
                  className: 'fixed inset-x-0 top-0 z-[3000] p-4 bg-red-600 text-white text-center font-bold shadow-lg',
                },
                globalError
              ),
            renderContent()
          )
        );
      }

      const Header = memo(({ theme, setTheme }) =>
        e(
          'header',
          { className: 'flex justify-between items-center my-8' },
          e(
            'div',
            null,
            e(
              'h1',
              {
                className: 'text-5xl font-bold text-gray-800 dark:text-gray-100',
              },
              'To-Do'
            ),
            e('p', { className: 'text-gray-500 dark:text-gray-400 mt-2' }, 'Your private and local task manager.')
          ),
          e(
            'button',
            {
              onClick: () => setTheme(theme === 'light' ? 'dark' : 'light'),
              className:
                'p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-50 dark:focus:ring-offset-gray-900 focus:ring-blue-500',
            },
            e('span', { className: 'sr-only' }, 'Toggle Theme'),
            theme === 'light' ? e(MoonIcon) : e(SunIcon)
          )
        )
      );

      const Footer = memo(
        ({
          activeTasksCount,
          filter,
          setFilter,
          onClearCompleted,
          handleSelectFolder,
          handleGenerateLog,
          onGenerateOldestTasks,
        }) =>
          e(
            'footer',
            {
              className:
                'mt-6 pt-4 border-t border-gray-200 dark:border-gray-700 flex justify-between items-center text-sm text-gray-500 dark:text-gray-400',
            },
            e('span', null, `${activeTasksCount} items left`),
            e(
              'div',
              { className: 'flex items-center space-x-4' },
              e(
                'button',
                {
                  onClick: () => setFilter('all'),
                  className: `hover:underline ${filter === 'all' ? 'text-blue-600' : ''}`,
                },
                'All'
              ),
              e(
                'button',
                {
                  onClick: () => setFilter('active'),
                  className: `hover:underline ${filter === 'active' ? 'text-blue-600' : ''}`,
                },
                'Active'
              ),
              e(
                'button',
                {
                  onClick: () => setFilter('completed'),
                  className: `hover:underline ${filter === 'completed' ? 'text-blue-600' : ''}`,
                },
                'Completed'
              )
            ),
            e(
              'div',
              { className: 'flex items-center space-x-4' },
              e(
                'button',
                {
                  onClick: onGenerateOldestTasks,
                  className: 'hover:underline text-green-500',
                },
                'Generate Task List'
              ),
              e('button', { onClick: handleSelectFolder, className: 'hover:underline' }, 'Change Folder'),
              e('button', { onClick: handleGenerateLog, className: 'hover:underline' }, 'Generate Log'),
              e('button', { onClick: onClearCompleted, className: 'hover:underline' }, 'Clear completed')
            )
          )
      );

      const MCNValidator = memo(({ text, validateMCN }) => {
        if (!text) return null;

        const validation = validateMCN(text);
        if (!validation.mcn) return null;

        if (validation.isValid) {
          const caseInfo = validation.case;
          return e(
            'span',
            {
              className: 'mcn-validation mcn-valid',
              title: ` MCN ${validation.mcn} - ${caseInfo.status || 'Valid Case'}`,
            },
            ''
          );
        } else {
          const suggestionText =
            validation.suggestions.length > 0 ? ` (Suggestions: ${validation.suggestions.join(', ')})` : '';
          return e(
            'span',
            {
              className: 'mcn-validation mcn-invalid',
              title: ` MCN ${validation.mcn} not found${suggestionText}`,
            },
            ''
          );
        }
      });

      const CmsNoteModal = memo(
        ({
          isOpen,
          onClose,
          onSave,
          initialNote,
          initialCategory,
          initialTimeSpent,
          isCompletion,
          isAlreadyComplete,
          cases,
        }) => {
          const [noteText, setNoteText] = useState(initialNote || '');
          const [category, setCategory] = useState(initialCategory || 'To-Do Completion');
          const [timeSpent, setTimeSpent] = useState(initialTimeSpent || '');
          const modalRef = useRef(null);

          const categoryOptions = useMemo(() => {
            // DEFENSIVE CHECK: Ensure cases is an array before attempting to use flatMap.
            const allNotes = (cases || []).flatMap((c) => c.notes || []);
            const uniqueCategories = [...new Set(allNotes.map((n) => n.category).filter(Boolean))];
            return uniqueCategories;
          }, [cases]);

          useEffect(() => {
            setNoteText(initialNote || '');
            // Set category from the task if it exists, otherwise use the default for a new completion.
            setCategory(initialCategory || (isCompletion ? 'To-Do Completion' : ''));
          }, [initialNote, initialCategory, isCompletion]);

          const handleSave = () => {
            if (isCompletion && noteText.trim() === '') {
              modalRef.current.style.outline = '2px solid red';
              setTimeout(() => {
                if (modalRef.current) modalRef.current.style.outline = 'none';
              }, 1000);
              return;
            }

            // If this is a completion note, copy the formatted text to clipboard
            if (isCompletion) {
              const textToCopy = `MLTC: ${noteText}`;
              navigator.clipboard.writeText(textToCopy).then(
                () => {
                  showToast('Completion note copied!');
                },
                () => {
                  showToast('Failed to copy note.', 'error');
                }
              );
            }

            onSave(category, noteText, timeSpent);
          };

          if (!isOpen) return null;

          return e(
            'div',
            {
              className: 'fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center',
              onClick: onClose,
            },
            e(
              'div',
              {
                ref: modalRef,
                className: 'bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg transition-all',
                onClick: (ev) => ev.stopPropagation(),
              },
              e('h2', { className: 'text-2xl font-bold mb-4' }, isCompletion ? 'Add Completion Note' : 'Edit Note'),
              e(
                'div',
                { className: 'space-y-4' },
                e(
                  'div',
                  null,
                  e(
                    'label',
                    {
                      htmlFor: 'note-category',
                      className: 'block text-sm font-medium text-gray-700 dark:text-gray-300',
                    },
                    'Category'
                  ),
                  e('input', {
                    type: 'text',
                    id: 'note-category',
                    list: 'note-category-datalist',
                    value: category,
                    onChange: (ev) => setCategory(ev.target.value),
                    placeholder: 'e.g., Client Call, Document Received',
                    className:
                      'mt-1 block w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-2',
                  }),
                  e(
                    'datalist',
                    { id: 'note-category-datalist' },
                    categoryOptions.map((cat) => e('option', { key: cat, value: cat }))
                  )
                ),
                e(
                  'div',
                  null,
                  e(
                    'label',
                    {
                      htmlFor: 'note-text',
                      className: 'block text-sm font-medium text-gray-700 dark:text-gray-300',
                    },
                    'Note'
                  ),
                  e('textarea', {
                    id: 'note-text',
                    value: noteText,
                    onChange: (ev) => setNoteText(ev.target.value),
                    className: 'w-full h-40 p-2 border rounded dark:bg-gray-700 dark:border-gray-600',
                    placeholder: 'Enter your notes here...',
                  })
                ),
                (isCompletion || isAlreadyComplete) &&
                  e(
                    'div',
                    null,
                    e(
                      'label',
                      {
                        htmlFor: 'time-spent',
                        className: 'block text-sm font-medium text-gray-700 dark:text-gray-300',
                      },
                      'Time Spent (minutes)'
                    ),
                    e('input', {
                      type: 'number',
                      id: 'time-spent',
                      value: timeSpent,
                      onChange: (ev) => setTimeSpent(ev.target.value),
                      placeholder: 'e.g., 15',
                      className:
                        'mt-1 block w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-2',
                    })
                  )
              ),
              e(
                'div',
                { className: 'flex justify-end space-x-4 mt-6' },
                e(
                  'button',
                  {
                    onClick: onClose,
                    className:
                      'px-4 py-2 rounded text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700',
                  },
                  'Cancel'
                ),
                e(
                  'button',
                  {
                    onClick: handleSave,
                    className: 'px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700',
                  },

                  'Save'
                )
              )
            )
          );
        }
      );

      const WorkLogModal = memo(({ isOpen, onClose, textContent, fileService }) => {
        const [content, setContent] = useState(textContent || '');
        const [copySuccess, setCopySuccess] = useState('');
        const textAreaRef = useRef(null);

        useEffect(() => {
          setContent(textContent || '');
        }, [textContent, isOpen]);

        const handleCopyToClipboard = () => {
          textAreaRef.current.select();
          try {
            document.execCommand('copy');
            setCopySuccess('Copied!');
            setTimeout(() => setCopySuccess(''), 2000);
          } catch (err) {
            setCopySuccess('Failed to copy.');
          }
        };

        const handleSaveLog = async () => {
          const fileName = `work-log-${dateUtils.formatToday('YYYY-MM-DD')}.txt`;
          const success = await fileService.writeTextFileToSubdirectory('workLogs', fileName, content);
          if (success) {
            showToast(`Saved ${fileName} to workLogs/ directory.`, 'success');
            onClose();
          }
        };

        if (!isOpen) return null;
        return e(
          'div',
          {
            className: 'fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center',
            onClick: onClose,
          },
          e(
            'div',
            {
              className: 'bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-2xl',
              onClick: (ev) => ev.stopPropagation(),
            },
            e('h2', { className: 'text-2xl font-bold mb-4' }, 'Generate Work Log'),
            e('textarea', {
              ref: textAreaRef,
              value: content,
              onChange: (ev) => setContent(ev.target.value),
              className: 'w-full h-64 p-2 border rounded dark:bg-gray-700 dark:border-gray-600 font-mono text-sm',
              placeholder: 'Your work log content will appear here...',
            }),
            e(
              'div',
              { className: 'flex justify-between items-center mt-4' },
              e('div', null, copySuccess && e('span', { className: 'text-green-500' }, copySuccess)),
              e(
                'div',
                { className: 'flex space-x-2' },
                e(
                  'button',
                  {
                    onClick: onClose,
                    className:
                      'px-4 py-2 rounded text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700',
                  },
                  'Cancel'
                ),
                e(
                  'button',
                  {
                    onClick: handleCopyToClipboard,
                    className: 'px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700',
                  },
                  'Copy to Clipboard'
                ),
                e(
                  'button',
                  {
                    onClick: handleSaveLog,
                    className: 'px-4 py-2 rounded bg-green-600 text-white hover:bg-green-700',
                  },
                  'Save Log to Directory'
                )
              )
            )
          )
        );
      });

      const BulkAddModal = memo(({ isOpen, onClose, onSave }) => {
        const [text, setText] = useState('');
        if (!isOpen) return null;
        return e(
          'div',
          {
            className: 'fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center',
            onClick: onClose,
          },
          e(
            'div',
            {
              className: 'bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-2xl',
              onClick: (ev) => ev.stopPropagation(),
            },
            e('h2', { className: 'text-2xl font-bold mb-4' }, 'Bulk Add Subtasks'),
            e(
              'p',
              { className: 'text-sm text-gray-600 dark:text-gray-400 mb-4' },
              'Paste your report snippet below. The app will create a unique subtask for each person in the format "ID - Name".'
            ),
            e('textarea', {
              value: text,
              onChange: (ev) => setText(ev.target.value),
              className: 'w-full h-64 p-2 border rounded dark:bg-gray-700 dark:border-gray-600 font-mono text-sm',
              placeholder: '12345\tDOE, JANE...',
            }),
            e(
              'div',
              { className: 'flex justify-end space-x-4 mt-4' },
              e(
                'button',
                {
                  onClick: onClose,
                  className:
                    'px-4 py-2 rounded text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700',
                },
                'Cancel'
              ),
              e(
                'button',
                {
                  onClick: () => {
                    onSave(text);
                    onClose();
                  },
                  className: 'px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700',
                },
                'Add Subtasks'
              )
            )
          )
        );
      });

      const EditableText = memo(({ text, onSave, tag: Tag = 'span', className = '' }) => {
        const [isEditing, setIsEditing] = useState(false);
        const [value, setValue] = useState(text);
        const inputRef = useRef(null);
        useEffect(() => {
          if (isEditing) inputRef.current.focus();
        }, [isEditing]);
        const handleSave = () => {
          if (value.trim() && value.trim() !== text) {
            onSave(value.trim());
          } else {
            setValue(text);
          }
          setIsEditing(false);
        };
        const handleKeyDown = (ev) => {
          if (ev.key === 'Enter') handleSave();
          if (ev.key === 'Escape') {
            setValue(text);
            setIsEditing(false);
          }
        };

        if (isEditing) {
          return e('input', {
            ref: inputRef,
            type: 'text',
            value: value,
            onChange: (ev) => setValue(ev.target.value),
            onBlur: handleSave,
            onKeyDown: handleKeyDown,
            className: `bg-inherit border-b-2 border-blue-500 focus:outline-none w-full ${className}`,
          });
        }
        return e(
          Tag,
          {
            onDoubleClick: () => setIsEditing(true),
            className: `cursor-pointer w-full ${className}`,
          },
          sanitize(text)
        );
      });

      const SubtaskInput = memo(({ taskId, onAddSubtask }) => {
        const [text, setText] = useState('');
        const handleSubmit = (ev) => {
          ev.preventDefault();
          onAddSubtask(taskId, text);
          setText('');
        };
        return e(
          'form',
          { onSubmit: handleSubmit, className: 'pl-8 pr-2 pt-2' },
          e('input', {
            type: 'text',
            value: text,
            onChange: (ev) => setText(ev.target.value),
            placeholder: 'Add a subtask...',
            className:
              'w-full text-sm px-3 py-2 bg-gray-100 dark:bg-gray-700 border-gray-600 rounded-md focus:ring-1 focus:ring-blue-500 focus:outline-none',
          })
        );
      });

      const TaskItem = memo(({ task, handlers, dragAndDrop }) => {
        if (task.type === 'single') {
          return e(SingleTaskItem, { task, handlers, dragAndDrop });
        }
        return e(MultiTaskItem, { task, handlers, dragAndDrop });
      });

      const SingleTaskItem = memo(({ task, handlers, dragAndDrop }) => {
        const { onToggleComplete, onUncompleteTask, onDelete, onConvertToMulti, onUpdate, onOpenNotes } = handlers;
        const { handleMainDrag, handleMainDrop, handleMainDragOver, handleDragEnd } = dragAndDrop;

        const MCN_REGEX = /\b(\d{5,})\b/;
        const mcnMatch = task.text.match(MCN_REGEX);

        const handleCaseLinkClick = (e) => {
          e.preventDefault();
          if (mcnMatch) {
            const mcn = mcnMatch[0];

            // Copy MCN to clipboard and show a toast notification.
            navigator.clipboard.writeText(mcn).then(
              () => {
                showToast(`MCN ${mcn} copied to clipboard.`, 'success');
              },
              () => {
                showToast('Failed to copy MCN.', 'error');
              }
            );

            let fallbackTimeout;

            // 1. Listen for an acknowledgment from the CMS
            const acknowledgementListener = (event) => {
              if (event.data.type === 'case_shown' && event.data.mcn === mcn) {
                console.log('CMS acknowledged showing the case. Cancelling fallback.');
                clearTimeout(fallbackTimeout);
                // The toast for focusing the tab was removed to avoid showing two success messages.
                // The "MCN copied" message now serves as the primary feedback.
                channel.removeEventListener('message', acknowledgementListener);
              }
            };
            channel.addEventListener('message', acknowledgementListener);

            // 2. Send the command to show the case
            channel.postMessage({ type: 'show_case', mcn });

            // 3. Set a fallback to open a new tab, which will be cancelled if we get an ack
            fallbackTimeout = setTimeout(() => {
              console.log('Fallback triggered: Opening new CMS tab.');
              window.open(`NightingaleCMS.html?mcn=${encodeURL(mcn)}`, '_blank');
              channel.removeEventListener('message', acknowledgementListener);
            }, 300); // Increased timeout slightly
          }
        };

        return e(
          'div',
          {
            draggable: true,
            onDragStart: (ev) => handleMainDrag(ev, task.id),
            onDragEnd: handleDragEnd,
            onDragOver: (ev) => handleMainDragOver(ev, task.id),
            onDrop: handleMainDrop,
            className: 'bg-white dark:bg-gray-800 rounded-xl shadow-md p-4 flex items-center justify-between group',
          },
          e(
            'div',
            { className: 'flex items-center flex-grow mr-4 min-w-0' },
            e('input', {
              type: 'checkbox',
              checked: task.completed,
              onChange: () => (task.completed ? onUncompleteTask(task.id) : onToggleComplete(task)),
              className:
                'h-5 w-5 rounded border-gray-300 dark:border-gray-500 text-blue-600 focus:ring-blue-500 cursor-pointer flex-shrink-0',
            }),
            e(
              'div',
              { className: 'ml-4 flex-grow min-w-0' },
              e(EditableText, {
                text: task.text,
                onSave: (newText) => onUpdate(task.id, 'text', newText),
                className: `w-full truncate ${
                  task.completed ? 'line-through text-gray-400' : 'text-gray-700 dark:text-gray-300'
                }`,
              }),
              e(MCNValidator, {
                text: task.text,
                validateMCN: handlers.validateMCN,
              })
            )
          ),
          e(
            'div',
            {
              className:
                'flex items-center space-x-2 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0',
            },
            e(
              'button',
              {
                onClick: () => onOpenNotes(task),
                className: 'text-gray-400 hover:text-blue-500',
                title: 'Edit Note',
              },
              e(NoteIcon)
            ),
            e(
              'button',
              {
                onClick: () => {
                  const noteText = task.notes || '';
                  if (noteText.trim()) {
                    const textToCopy = `MLTC: ${noteText}`;
                    navigator.clipboard.writeText(textToCopy).then(() => showToast('Note copied!'));
                  } else {
                    showToast('Task has no notes to copy.', 'warning');
                  }
                },
                className: 'text-gray-400 hover:text-green-500',
                title: 'Copy Note Text',
              },
              e(CopyIcon)
            ),
            mcnMatch &&
              e(
                'button',
                {
                  onClick: (e) => handleCaseLinkClick(e, task.text),
                  className: 'text-gray-400 hover:text-blue-500',
                  title: `Open or Create Case ${mcnMatch[0]}`,
                },
                e(
                  'svg',
                  {
                    xmlns: 'http://www.w3.org/2000/svg',
                    className: 'h-5 w-5',
                    fill: 'none',
                    viewBox: '0 0 24 24',
                    stroke: 'currentColor',
                  },
                  e('path', {
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeWidth: 2,
                    d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14',
                  })
                )
              ),
            e(
              'button',
              {
                onClick: () => onConvertToMulti(task.id),
                className: 'text-xs text-blue-500 hover:text-blue-700 font-semibold',
              },
              'Add Subtasks'
            ),
            e(
              'button',
              {
                onClick: () => onDelete(task.id),
                className: 'text-gray-400 hover:text-red-500',
              },
              e(
                'svg',
                {
                  xmlns: 'http://www.w3.org/2000/svg',
                  className: 'h-5 w-5',
                  fill: 'none',
                  viewBox: '0 0 24 24',
                  stroke: 'currentColor',
                },
                e('path', {
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeWidth: 2,
                  d: 'M6 18L18 6M6 6l12 12',
                })
              )
            )
          )
        );
      });

      const MultiTaskItem = memo(({ task, handlers, dragAndDrop }) => {
        const {
          onToggleComplete,
          onUncompleteTask,
          onDelete,
          onAddSubtask,
          onUpdate,
          onToggleCollapse,
          onOpenNotes,
          onOpenBulkAdd,
          handleCaseLinkClick, // We will get this from handlers now
        } = handlers;
        const {
          handleMainDrag,
          handleSubtaskDrag,
          handleMainDrop,
          handleSubtaskDrop,
          handleMainDragOver,
          handleSubtaskDragOver,
          handleDragEnd,
        } = dragAndDrop;
        const isMultiTaskComplete = task.subtasks.length > 0 && task.subtasks.every((sub) => sub.completed);

        const MCN_REGEX = /\b(\d{5,})\b/;

        return e(
          'div',
          {
            draggable: true,
            onDragStart: (ev) => handleMainDrag(ev, task.id),
            onDragEnd: handleDragEnd,
            onDragOver: (ev) => handleMainDragOver(ev, task.id),
            onDrop: handleMainDrop,
            className: 'bg-white dark:bg-gray-800 rounded-xl shadow-md p-4 group',
          },
          e(
            'div',
            { className: 'flex items-center justify-between' },
            e(
              'div',
              {
                className: 'flex items-center flex-grow cursor-pointer',
                onClick: () => onToggleCollapse(task.id),
              },
              e(
                'span',
                {
                  className: 'transition-transform duration-300',
                  style: {
                    transform: task.isCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)',
                  },
                },
                e(ChevronDownIcon)
              ),
              e(
                'div',
                { onClick: (ev) => ev.stopPropagation(), className: 'w-full' },
                e(EditableText, {
                  tag: 'h3',
                  text: task.text,
                  onSave: (newText) => onUpdate(task.id, 'text', newText),
                  className: `ml-2 text-xl font-bold ${
                    isMultiTaskComplete ? 'line-through text-gray-400' : 'text-gray-800 dark:text-gray-200'
                  }`,
                })
              )
            ),
            e(
              'div',
              {
                className:
                  'flex items-center space-x-2 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0',
              },
              e(
                'button',
                {
                  onClick: () => onOpenNotes(task),
                  className: 'text-gray-400 hover:text-blue-500',
                  title: 'Notes',
                },
                e(NoteIcon)
              ),
              e(
                'button',
                {
                  onClick: () => onOpenBulkAdd(task),
                  className: 'text-gray-400 hover:text-green-500',
                  title: 'Bulk Add',
                },
                e(BulkAddIcon)
              ),
              e(
                'button',
                {
                  onClick: () => onDelete(task.id),
                  className: 'text-gray-400 hover:text-red-500',
                  title: 'Delete',
                },
                e(
                  'svg',
                  {
                    xmlns: 'http://www.w3.org/2000/svg',
                    className: 'h-5 w-5',
                    fill: 'none',
                    viewBox: '0 0 24 24',
                    stroke: 'currentColor',
                  },
                  e('path', {
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeWidth: 2,
                    d: 'M6 18L18 6M6 6l12 12',
                  })
                )
              )
            )
          ),
          e(
            'div',
            {
              className: `subtask-container ${task.isCollapsed ? 'collapsed' : ''}`,
            },
            e(
              'ul',
              {
                className: 'mt-3 space-y-2 pl-4 border-l-2 border-gray-200 dark:border-gray-700 ml-2',
              },
              task.subtasks.map((sub, subIndex) => {
                const subtaskMcnMatch = sub.text.match(MCN_REGEX);
                return e(
                  'li',
                  {
                    key: sub.id,
                    draggable: true,
                    onDragStart: (ev) => {
                      ev.stopPropagation();
                      handleSubtaskDrag(ev, task.id, sub.id);
                    },
                    onDragEnd: handleDragEnd,
                    onDragOver: (ev) => handleSubtaskDragOver(ev, task.id, sub.id),
                    onDrop: (ev) => {
                      ev.stopPropagation();
                      handleSubtaskDrop();
                    },
                    className: 'flex items-center justify-between group/sub p-1 rounded-md',
                  },
                  e(
                    'div',
                    { className: 'flex items-center flex-grow mr-2 min-w-0' },
                    e('span', { className: 'cursor-grab' }, e(DragHandleIcon)),
                    e('input', {
                      type: 'checkbox',
                      checked: sub.completed,
                      onChange: () =>
                        sub.completed ? onUncompleteTask(task.id, sub.id) : onToggleComplete(task, sub.id),
                      className:
                        'h-5 w-5 rounded border-gray-300 dark:border-gray-500 text-blue-600 focus:ring-blue-500 cursor-pointer ml-2',
                    }),
                    e(
                      'div',
                      { className: 'ml-3 flex-grow min-w-0' },
                      e(EditableText, {
                        text: sub.text,
                        onSave: (newText) => onUpdate(task.id, 'text', newText, sub.id),
                        className: `w-full truncate ${
                          sub.completed ? 'line-through text-gray-400' : 'text-gray-600 dark:text-gray-300'
                        }`,
                      }),
                      e(MCNValidator, {
                        text: sub.text,
                        validateMCN: handlers.validateMCN,
                      })
                    )
                  ),
                  e(
                    'div',
                    {
                      className:
                        'flex items-center space-x-2 opacity-0 group-hover/sub:opacity-100 transition-opacity flex-shrink-0',
                    },
                    e(
                      'button',
                      {
                        onClick: () => onOpenNotes(task, sub.id),
                        className: 'text-gray-400 hover:text-blue-500',
                        title: 'Edit Note',
                      },
                      e(NoteIcon)
                    ),
                    e(
                      'button',
                      {
                        onClick: () => {
                          const noteText = sub.notes || '';
                          if (noteText.trim()) {
                            const textToCopy = `MLTC: ${noteText}`;
                            navigator.clipboard.writeText(textToCopy).then(() => showToast('Note copied!'));
                          } else {
                            showToast('Subtask has no notes to copy.', 'warning');
                          }
                        },
                        className: 'text-gray-400 hover:text-green-500',
                        title: 'Copy Note Text',
                      },
                      e(CopyIcon)
                    ),
                    subtaskMcnMatch &&
                      e(
                        'button',
                        {
                          onClick: (e) => handleCaseLinkClick(e, sub.text),
                          className: 'text-gray-400 hover:text-blue-500',
                          title: `Open or Create Case ${subtaskMcnMatch[0]}`,
                        },
                        e(
                          'svg',
                          {
                            xmlns: 'http://www.w3.org/2000/svg',
                            className: 'h-4 w-4',
                            fill: 'none',
                            viewBox: '0 0 24 24',
                            stroke: 'currentColor',
                          },
                          e('path', {
                            strokeLinecap: 'round',
                            strokeLinejoin: 'round',
                            strokeWidth: 2,
                            d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14',
                          })
                        )
                      ),
                    e(
                      'button',
                      {
                        onClick: () => onDelete(task.id, sub.id),
                        className: 'text-gray-400 hover:text-red-500',
                      },
                      e(
                        'svg',
                        {
                          xmlns: 'http://www.w3.org/2000/svg',
                          className: 'h-4 w-4',
                          fill: 'none',
                          viewBox: '0 0 24 24',
                          stroke: 'currentColor',
                        },
                        e('path', {
                          strokeLinecap: 'round',
                          strokeLinejoin: 'round',
                          strokeWidth: 2,
                          d: 'M6 18L18 6M6 6l12 12',
                        })
                      )
                    )
                  )
                );
              })
            ),
            e(SubtaskInput, { taskId: task.id, onAddSubtask: onAddSubtask })
          )
        );
      });

      const container = document.getElementById('root');
      const root = ReactDOM.createRoot(container);
      root.render(e(App));
    </script>
  </body>
</html>
