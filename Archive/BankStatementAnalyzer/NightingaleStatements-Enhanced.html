<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bank Statement Reviewer - Enhanced</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          BlinkMacSystemFont,
          'Segoe UI',
          Roboto,
          Oxygen,
          Ubuntu,
          Cantarell,
          'Open Sans',
          'Helvetica Neue',
          sans-serif;
        margin: 2em;
        color: #333;
        background-color: #f8f9fa;
      }
      h1 {
        color: #1a1a1a;
      }
      #root {
        padding: 1.5em;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        background-color: #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      /* New Page Grid Layout */
      .page-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
        gap: 2em;
      }

      /* Month Card Styles with Header */
      .month-card {
        border: 1px solid #dee2e6;
        border-radius: 8px;
        margin-bottom: 2em;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      .month-header {
        background-color: #f8f9fa;
        padding: 0.75em 1em;
        border-bottom: 1px solid #dee2e6;
        text-align: center;
        font-weight: bold;
      }
      .year-label {
        font-size: 1.5em;
        color: #333;
        margin-right: 0.5em;
      }
      .month-label {
        font-size: 1.2em;
        color: #007bff;
      }
      .transactions-column {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
      }
      .transaction-row {
        display: grid;
        grid-template-columns: 1fr 3fr 1fr 1fr 1fr;
        padding: 0.75em 1em;
        border-bottom: 1px solid #e9ecef;
        text-align: right;
        align-items: center;
      }
      .transaction-header {
        display: grid;
        grid-template-columns: 1fr 3fr 1fr 1fr 1fr;
        padding: 0.75em 1em;
        background-color: #f1f3f5;
        font-weight: bold;
        text-align: right;
        color: #495057;
      }
      .transaction-header div {
        cursor: pointer;
        user-select: none;
        transition: background-color 0.2s;
        padding: 0.25em;
        border-radius: 4px;
      }
      .transaction-header div:hover {
        background-color: #e9ecef;
      }
      .sort-indicator {
        margin-left: 0.5em;
        font-size: 0.8em;
      }
      .filter-controls {
        display: flex;
        gap: 1em;
        align-items: center;
        margin-left: 1em;
      }
      .filter-select {
        padding: 0.25em 0.5em;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        font-size: 0.9em;
      }

      /* Print Styles for Landscape Format */
      @media print {
        body {
          margin: 0;
          padding: 0;
          background: white;
          font-size: 10pt;
        }

        h1 {
          display: none;
        }

        /* Hide upload section completely */
        .file-upload-section {
          display: none !important;
        }

        #root > div:first-child {
          display: none !important;
        }

        /* Optimize page layout for landscape */
        .page-grid {
          display: block;
          margin: 0;
          padding: 0;
        }

        .month-card {
          page-break-inside: avoid;
          margin-bottom: 1em;
          border: 1px solid #000;
          box-shadow: none;
        }

        .month-header {
          background: #f0f0f0 !important;
          -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
          font-size: 12pt;
          font-weight: bold;
          border-bottom: 1px solid #000;
        }

        /* Hide filter controls in print */
        .filter-controls {
          display: none !important;
        }

        .transaction-header {
          background: #f8f8f8 !important;
          -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
          font-size: 9pt;
          font-weight: bold;
          border-bottom: 1px solid #000;
        }

        .transaction-row {
          font-size: 8pt;
          border-bottom: 1px solid #ccc;
          padding: 0.5em 1em;
          grid-template-columns: 1fr 3fr 1fr 1fr 1fr;
        }

        .balance-summary {
          background: #f0f0f0 !important;
          -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
          font-size: 9pt;
          font-weight: bold;
          border-top: 1px solid #000;
        }

        /* Ensure text colors print correctly */
        .credit {
          color: #000 !important;
        }

        .debit {
          color: #000 !important;
        }

        /* Hide sort indicators in print */
        .sort-indicator {
          display: none;
        }

        /* Optimize for landscape orientation */
        @page {
          size: landscape;
          margin: 0.5in;
        }
      }
      .transaction-description {
        text-align: left;
      }
      .transaction-date {
        text-align: left;
      }
      .balance-summary {
        display: flex;
        justify-content: space-around;
        padding: 0.75em 1em;
        background-color: #f8f9fa;
        font-weight: bold;
        margin-top: auto;
      }
      .balance {
        font-weight: bold;
      }
      .credit {
        color: #28a745;
      }
      .debit {
        color: #dc3545;
      }

      /* Warning flag styles */
      .warning-flag {
        font-size: 16px;
        margin-left: 8px;
        cursor: help;
      }

      /* Parsing Error - Data validation issues */
      .parsing-error {
        color: #dc3545;
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 3px;
        padding: 2px 4px;
        font-size: 14px;
      }

      /* OCR Uncertainty - Low confidence text recognition */
      .ocr-uncertainty {
        color: #856404;
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 3px;
        padding: 2px 4px;
        font-size: 14px;
      }

      .warning-row {
        background-color: #fef3cd;
      }

      .parsing-error-row {
        background-color: #f8d7da;
      }

      .ocr-uncertainty-row {
        background-color: #fff3cd;
      }

      .warning-tooltip {
        position: relative;
      }
      .warning-tooltip:hover::after {
        content: attr(title);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #333;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 1000;
      }

      /* Warning Legend */
      .warning-legend {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 8px 12px;
        margin: 8px 0;
        font-size: 12px;
        display: flex;
        gap: 16px;
        align-items: center;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .legend-icon {
        font-size: 14px;
      }

      /* Enhanced OCR status indicators */
      .ocr-status {
        display: inline-block;
        padding: 0.25em 0.5em;
        border-radius: 4px;
        font-size: 0.8em;
        font-weight: bold;
        margin-left: 1em;
      }
      .ocr-enhanced {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      .ocr-fallback {
        background-color: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
      }
      .systematic-error-badge {
        background-color: #f8d7da;
        color: #721c24;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-size: 0.7em;
        margin-left: 0.5em;
      }
    </style>

    <script src="https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
    <script src="https://unpkg.com/tesseract.js@2.1.4/dist/tesseract.min.js"></script>
    <!-- Enhanced Image Processing Dependencies - Production Versions -->
    <script src="https://unpkg.com/jimp@0.22.10/browser/lib/jimp.min.js"></script>
    <!-- Backup Jimp source in case primary fails -->
    <script>
      // Verify Jimp loaded, try backup if needed
      if (typeof Jimp === 'undefined') {
        console.warn('‚ö†Ô∏è Primary Jimp source failed, loading backup...');
        const backup = document.createElement('script');
        backup.src = 'https://cdn.jsdelivr.net/npm/jimp@0.22.10/browser/lib/jimp.min.js';
        backup.async = false;
        document.head.appendChild(backup);
      } else {
        console.log('‚úÖ Jimp loaded successfully');
      }
    </script>
    <script src="https://unpkg.com/fuse.js@6.6.2/dist/fuse.min.js"></script>
    <!-- Include React and ReactDOM - Production Versions -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script>
      // Required configuration for PDF.js
      pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.worker.min.js`;
      /**
       * Enhanced OCR processing without the problematic scheduler
       */
      /**
       * STAGE 1: IMAGE PREPROCESSING WITH JIMP
       * Goal: Create a perfectly clean, high-contrast, black-and-white image
       */
      async function stage1_PrepareImage(canvas) {
        try {
          console.log('üñºÔ∏è  Stage 1: Preparing image with Jimp preprocessing...');

          // Check if Jimp is available
          if (typeof Jimp === 'undefined') {
            console.warn('‚ö†Ô∏è  Jimp not available, falling back to canvas preprocessing');
            throw new Error('Jimp not loaded');
          }

          console.log('‚úÖ Jimp is available, proceeding with advanced preprocessing...');

          // Convert canvas to blob for Jimp processing
          const blob = await new Promise((resolve) => {
            canvas.toBlob(resolve, 'image/png');
          });

          // Convert blob to array buffer for browser compatibility
          const arrayBuffer = await blob.arrayBuffer();
          // Use Uint8Array instead of Buffer for browser compatibility
          const uint8Array = new Uint8Array(arrayBuffer);

          // Load image into Jimp using array buffer
          const image = await Jimp.read(arrayBuffer);

          console.log(`Original image: ${image.getWidth()}x${image.getHeight()}`);

          // Step 1: Convert to grayscale
          image.grayscale();
          console.log('‚úÖ Converted to grayscale');

          // Step 2: Increase contrast significantly
          image.contrast(0.8); // Boost contrast for bolder text
          console.log('‚úÖ Enhanced contrast');

          // Step 3: Apply threshold-based binarization
          // This creates pure black text on pure white background
          image.contrast(1.0); // Maximum contrast

          // Custom binarization with threshold
          image.scan(0, 0, image.bitmap.width, image.bitmap.height, function (x, y, idx) {
            const gray = this.bitmap.data[idx]; // R, G, B are same in grayscale
            const threshold = 128; // Adjust this value if needed (0-255)

            // Convert to pure black (0) or pure white (255)
            const binaryValue = gray < threshold ? 0 : 255;

            this.bitmap.data[idx] = binaryValue; // R
            this.bitmap.data[idx + 1] = binaryValue; // G
            this.bitmap.data[idx + 2] = binaryValue; // B
            // Alpha channel (idx + 3) stays unchanged
          });

          console.log('‚úÖ Applied binarization threshold');

          // Step 4: Optional noise reduction (remove small artifacts)
          // This helps remove tiny specks that can confuse OCR
          const cleanedImage = image.clone();

          // Simple noise reduction: if a pixel is surrounded by opposite colors, flip it
          cleanedImage.scan(1, 1, image.bitmap.width - 2, image.bitmap.height - 2, function (x, y, idx) {
            const current = this.bitmap.data[idx];
            const neighbors = [
              image.bitmap.data[image.getPixelIndex(x - 1, y)], // left
              image.bitmap.data[image.getPixelIndex(x + 1, y)], // right
              image.bitmap.data[image.getPixelIndex(x, y - 1)], // top
              image.bitmap.data[image.getPixelIndex(x, y + 1)], // bottom
            ];

            // Count white vs black neighbors
            const whiteNeighbors = neighbors.filter((n) => n > 128).length;
            const blackNeighbors = neighbors.filter((n) => n <= 128).length;

            // If current pixel is isolated (different from majority of neighbors), flip it
            if (current <= 128 && whiteNeighbors >= 3) {
              // Black pixel surrounded by white - likely noise
              this.bitmap.data[idx] = 255;
              this.bitmap.data[idx + 1] = 255;
              this.bitmap.data[idx + 2] = 255;
            } else if (current > 128 && blackNeighbors >= 3) {
              // White pixel surrounded by black - likely noise
              this.bitmap.data[idx] = 0;
              this.bitmap.data[idx + 1] = 0;
              this.bitmap.data[idx + 2] = 0;
            }
          });

          console.log('‚úÖ Applied noise reduction');

          // Get cleaned image buffer for Tesseract
          const cleanedBuffer = await cleanedImage.getBufferAsync(Jimp.MIME_PNG);
          console.log(`üéØ Stage 1 Complete: Clean image prepared (${cleanedBuffer.length} bytes)`);

          return cleanedBuffer;
        } catch (error) {
          console.warn('‚ö†Ô∏è  Stage 1 failed, falling back to canvas preprocessing:', error);

          // Fallback to original canvas preprocessing
          const context = canvas.getContext('2d');
          const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          // Simple contrast enhancement
          for (let i = 0; i < data.length; i += 4) {
            const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            const enhanced = gray < 128 ? Math.max(0, gray - 20) : Math.min(255, gray + 20);
            data[i] = enhanced;
            data[i + 1] = enhanced;
            data[i + 2] = enhanced;
          }

          context.putImageData(imageData, 0, 0);

          // Return canvas for browser compatibility instead of Buffer
          return canvas;
        }
      }

      /**
       * STAGE 2: OCR WITH ENHANCED TESSERACT CONFIGURATION
       * Goal: Extract raw text with optimal settings for financial documents
       */
      async function stage2_RecognizeText(cleanImageBuffer) {
        console.log('üìñ Stage 2: Performing OCR with enhanced Tesseract configuration...');

        let worker = null;

        try {
          // Initialize Tesseract worker
          worker = Tesseract.createWorker();
          await worker.load();
          await worker.loadLanguage('eng');
          await worker.initialize('eng');

          // CRITICAL: Configure parameters for bank statements
          console.log('‚öôÔ∏è  Configuring Tesseract for financial documents...');

          // Whitelist only characters expected on bank statements
          await worker.setParameters({
            tessedit_char_whitelist: '0123456789.,$/()-# ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&*:',
          });

          // Preserve layout and spacing (crucial for column detection)
          await worker.setParameters({
            preserve_interword_spaces: '1',
          });

          // Use automatic page segmentation for financial documents
          await worker.setParameters({
            tessedit_pageseg_mode: Tesseract.PSM.AUTO,
          });

          // Additional parameters for better accuracy
          await worker.setParameters({
            tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY, // Use neural network
            tessedit_do_invert: '0', // Don't invert (we already processed)
          });

          console.log('‚úÖ Tesseract configured for financial documents');

          // Perform OCR recognition
          console.log('üîç Running OCR recognition...');
          const {
            data: { text, confidence },
          } = await worker.recognize(cleanImageBuffer);

          console.log(
            `üéØ Stage 2 Complete: Text extracted (${text.length} chars, ${confidence.toFixed(1)}% confidence)`
          );

          return {
            text: text,
            confidence: confidence,
            raw: text, // Keep raw text for debugging
          };
        } catch (error) {
          console.error('‚ùå Stage 2 OCR failed:', error);
          throw error;
        } finally {
          // Always clean up the worker
          if (worker) {
            await worker.terminate();
          }
        }
      }

      /**
       * STAGE 3: POST-PROCESSING WITH REGEX & FUSE.JS
       * Goal: Transform raw text into clean, structured JSON data
       */
      async function stage3_RefineData(ocrResult) {
        console.log('üîß Stage 3: Refining data with RegEx patterns and Fuse.js...');

        const { text, confidence } = ocrResult;

        // Step 1: Split into lines and clean
        const rawLines = text
          .split('\n')
          .map((line) => line.trim())
          .filter((line) => line.length > 0);
        console.log(`üìù Processing ${rawLines.length} text lines...`);

        // Step 2: Enhanced transaction detection patterns
        const transactionPatterns = [
          // Pattern 1: MM/DD/YYYY Description Amount
          /(\d{1,2}\/\d{1,2}\/\d{4})\s+(.+?)\s+([\d,]+\.?\d{0,2})$/,

          // Pattern 2: MM/DD Description Amount (no year)
          /(\d{1,2}\/\d{1,2})\s+(.+?)\s+([\d,]+\.?\d{0,2})$/,

          // Pattern 3: DD-MMM-YYYY or DD-MMM (with dashes)
          /(\d{1,2}-[A-Z]{3}-?\d{0,4})\s+(.+?)\s+([\d,]+\.?\d{0,2})$/,

          // Pattern 4: More flexible amount detection (with parentheses for debits)
          /(\d{1,2}[\/\-]\d{1,2}[\/\-]?\d{0,4})\s+(.+?)\s+\$?([\d,]+\.?\d{0,2}|\([\d,]+\.?\d{0,2}\))$/,
        ];

        // Step 3: Known transaction types for Fuse.js matching
        const knownTransactionTypes = [
          'DEPOSIT',
          'WITHDRAWAL',
          'ATM',
          'CHECK',
          'TRANSFER',
          'PAYMENT',
          'INTEREST',
          'FEE',
          'CHARGE',
          'VENMO',
          'PAYPAL',
          'ZELLE',
          'DEBIT CARD',
          'CREDIT CARD',
          'OVERDRAFT',
          'RETURN',
          'DIRECT DEPOSIT',
          'WIRE TRANSFER',
          'ACH',
          'ELECTRONIC',
          'BRANCH DEPOSIT',
          'MOBILE DEPOSIT',
          'ONLINE TRANSFER',
        ];

        // Initialize Fuse.js for fuzzy matching
        const fuse = new Fuse(knownTransactionTypes, {
          threshold: 0.4, // Allow some OCR errors
          distance: 100,
          keys: [], // We're matching strings directly
        });

        const transactions = [];
        const unmatched = [];

        // Step 4: Process each line
        for (let i = 0; i < rawLines.length; i++) {
          const line = rawLines[i];
          let matched = false;

          // Try each transaction pattern
          for (const pattern of transactionPatterns) {
            const match = line.match(pattern);

            if (match) {
              const [, dateStr, description, amountStr] = match;

              // Clean and validate the extracted data
              const cleanedTransaction = cleanTransactionData(
                {
                  date: dateStr,
                  description: description,
                  amount: amountStr,
                  lineNumber: i + 1,
                  originalLine: line,
                },
                fuse
              );

              if (cleanedTransaction) {
                transactions.push(cleanedTransaction);
                matched = true;
                break;
              }
            }
          }

          if (!matched && line.length > 10) {
            unmatched.push({ lineNumber: i + 1, text: line });
          }
        }

        console.log(`‚úÖ Extracted ${transactions.length} transactions`);
        console.log(`‚ö†Ô∏è  ${unmatched.length} lines didn't match transaction patterns`);

        // Step 5: Post-process and validate
        const validatedTransactions = validateTransactionSequence(transactions);

        console.log(`üéØ Stage 3 Complete: ${validatedTransactions.length} validated transactions`);

        return {
          transactions: validatedTransactions,
          unmatched: unmatched,
          confidence: confidence,
          stats: {
            totalLines: rawLines.length,
            matched: transactions.length,
            unmatched: unmatched.length,
            ocrConfidence: confidence,
          },
        };
      }

      /**
       * Clean and standardize extracted transaction data
       */
      function cleanTransactionData(raw, fuse) {
        try {
          // Clean date
          let cleanDate = raw.date.replace(/[^\d\/\-]/g, '');
          if (!cleanDate.includes('/') && !cleanDate.includes('-')) {
            return null; // Invalid date format
          }

          // Clean amount
          let cleanAmount = raw.amount
            .replace(/[$,\s]/g, '') // Remove currency symbols, commas, spaces
            .replace(/[^\d\.\(\)]/g, ''); // Keep only digits, decimals, parentheses

          // Handle parentheses (debit notation)
          const isDebit = cleanAmount.includes('(') || cleanAmount.includes(')');
          cleanAmount = cleanAmount.replace(/[\(\)]/g, '');

          // Convert to number
          const amount = parseFloat(cleanAmount);
          if (isNaN(amount)) {
            return null; // Invalid amount
          }

          // Clean description
          let cleanDescription = raw.description
            .trim()
            .replace(/\s+/g, ' ') // Normalize whitespace
            .replace(/[^\w\s\#\&\-\.]/g, ''); // Remove special characters except common ones

          // Use Fuse.js to standardize transaction type
          const fuseResults = fuse.search(cleanDescription);
          const standardizedType = fuseResults.length > 0 ? fuseResults[0].item : null;

          return {
            date: cleanDate,
            description: cleanDescription,
            standardizedType: standardizedType,
            amount: isDebit ? -amount : amount,
            isDebit: isDebit,
            confidence: fuseResults.length > 0 ? 1 - fuseResults[0].score : 0.5,
            lineNumber: raw.lineNumber,
            originalLine: raw.originalLine,
          };
        } catch (error) {
          console.warn('Failed to clean transaction data:', error, raw);
          return null;
        }
      }

      /**
       * Validate sequence and detect potential OCR errors
       */
      function validateTransactionSequence(transactions) {
        // Sort by line number to maintain document order
        transactions.sort((a, b) => a.lineNumber - b.lineNumber);

        const validated = [];

        for (let i = 0; i < transactions.length; i++) {
          const transaction = { ...transactions[i] };

          // Add validation flags with categorization
          transaction.warnings = [];
          transaction.parsingErrors = []; // Data validation issues
          transaction.ocrUncertainty = []; // Low confidence OCR issues

          // Check for suspicious amounts (parsing error - data validation)
          if (Math.abs(transaction.amount) > 50000) {
            transaction.parsingErrors.push('Large amount detected - verify accuracy');
          }

          // Check for missing decimals (parsing error - common OCR formatting issue)
          if (Math.abs(transaction.amount) >= 100 && transaction.amount % 1 === 0) {
            transaction.parsingErrors.push('Whole dollar amount - verify no missing decimals');
          }

          // Check description quality (OCR uncertainty - low confidence text recognition)
          if (transaction.confidence < 0.3) {
            transaction.ocrUncertainty.push('Low confidence in transaction type matching');
          }

          // Check OCR confidence from Tesseract
          if (transaction.ocrConfidence && transaction.ocrConfidence < 60) {
            transaction.ocrUncertainty.push(`Low OCR confidence: ${transaction.ocrConfidence.toFixed(1)}%`);
          }

          // Combine for legacy compatibility
          transaction.warnings = [...transaction.parsingErrors, ...transaction.ocrUncertainty];
          transaction.hasWarnings = transaction.warnings.length > 0;
          transaction.hasParsingErrors = transaction.parsingErrors.length > 0;
          transaction.hasOcrUncertainty = transaction.ocrUncertainty.length > 0;

          validated.push(transaction);
        }

        return validated;
      }

      /**
       * MAIN ENHANCED OCR FUNCTION - Orchestrates all 3 stages
       */
      async function enhancedOCRProcessing(canvas) {
        console.log('üöÄ Starting Enhanced 3-Stage OCR Pipeline...');

        try {
          // Stage 1: Prepare Image
          const cleanImage = await stage1_PrepareImage(canvas);

          // Stage 2: Recognize Text
          const ocrResult = await stage2_RecognizeText(cleanImage);

          // Stage 3: Refine Data
          const refinedData = await stage3_RefineData(ocrResult);

          console.log('üéâ Enhanced OCR Pipeline Complete!');
          console.log(`üìä Results: ${refinedData.transactions.length} transactions extracted`);
          console.log(`üìà OCR Confidence: ${refinedData.confidence.toFixed(1)}%`);

          // Return in format expected by existing code
          return ocrResult.text; // For compatibility
        } catch (error) {
          console.error('‚ùå Enhanced OCR Pipeline failed:', error);

          // Fallback to original simple OCR
          console.log('üîÑ Falling back to simple OCR...');

          const context = canvas.getContext('2d');
          const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          for (let i = 0; i < data.length; i += 4) {
            const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            const enhanced = gray < 128 ? Math.max(0, gray - 20) : Math.min(255, gray + 20);
            data[i] = enhanced;
            data[i + 1] = enhanced;
            data[i + 2] = enhanced;
          }

          context.putImageData(imageData, 0, 0);

          // Simple fallback OCR with minimal settings
          const {
            data: { text },
          } = await Tesseract.recognize(canvas, 'eng', {
            logger: null,
            tessedit_char_whitelist: '0123456789.,$()- ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz/#&',
          });

          return text;
        }
      }

      /**
       * Enhanced parsing that addresses the balance calculation issues
       */
      function parseStatementTextEnhanced(text) {
        const originalLines = text.split('\n');
        const yearlyData = {};
        const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
        const creditKeywords = [
          'DEPOSIT',
          'INTEREST EARNED',
          'FROM',
          'VENMO PAYMENT FROM',
          'CHECK #',
          'MOBILE DEPOSIT',
          'CASH DEPOSIT',
          'TRANSFER FROM',
          'INCOMING',
          'CREDIT',
        ];

        // Enhanced date patterns for better recognition
        const datePatterns = [
          /^\s*(\d{1,2}[.,\/]\d{1,2}[.,\/]\d{4})/, // MM/DD/YYYY
          /^\s*(\d{1,2}[.,\/]\d{1,2}[.,\/]\d{2})/, // MM/DD/YY
          /(\d{1,2}[.,\/]\d{1,2}[.,\/]\d{4})/, // Date anywhere in line
          /^\s*(\d{1,2}[\s-]\w{3}[\s-]\d{4})/, // DD-MMM-YYYY
        ];

        // Enhanced money extraction patterns
        const moneyPatterns = [
          /\$[\d,]+\.?\d*/g, // Standard $123.45
          /\([\d,]+\.?\d*\)/g, // (123.45) for debits
          /[\d,]+\.\d{2}\b/g, // 123.45 (with word boundary)
          /\b[\d,]{1,}(?:\.\d{2})?\b/g, // Flexible with word boundaries
        ];

        console.log('üîç Starting enhanced parsing...');
        let allTransactions = [];

        for (let i = 0; i < originalLines.length; i++) {
          let line = originalLines[i].trim();
          let dateMatch = null;
          let usedPattern = null;

          // Try multiple date patterns
          for (const pattern of datePatterns) {
            dateMatch = line.match(pattern);
            if (dateMatch) {
              usedPattern = pattern;
              break;
            }
          }

          if (dateMatch) {
            let fullDescription = line.replace(usedPattern, '').trim();
            let nextIndex = i + 1;

            // Look ahead for continuation lines but be more selective
            while (nextIndex < originalLines.length && !datePatterns.some((p) => p.test(originalLines[nextIndex]))) {
              const continuation = originalLines[nextIndex].trim();
              if (
                continuation &&
                !continuation.toLowerCase().includes('date description') &&
                !continuation.toLowerCase().includes('balance') &&
                !continuation.toLowerCase().includes('credits') &&
                !continuation.toLowerCase().includes('debits') &&
                continuation.length > 2
              ) {
                fullDescription += ` ${continuation}`;
              }
              nextIndex++;
            }

            fullDescription = fullDescription.replace(/\s+/g, ' ').trim();

            // Enhanced money extraction
            let moneyValues = [];
            for (const pattern of moneyPatterns) {
              const matches = fullDescription.match(pattern) || [];
              moneyValues = moneyValues.concat(matches);
            }

            // Remove duplicates and parse numbers more carefully
            moneyValues = [...new Set(moneyValues)];
            const numbers = moneyValues
              .map((val) => {
                let num = val.replace(/[$,()]/g, '');
                const parsed = parseFloat(num);
                return isNaN(parsed) ? 0 : parsed;
              })
              .filter((n) => n > 0);

            console.log('üí∞ Money extraction for line:', {
              originalLine: line,
              fullDescription: fullDescription,
              moneyValues: moneyValues,
              numbers: numbers,
            });

            // Clean description
            let cleanDescription = fullDescription;
            moneyValues.forEach((val) => {
              cleanDescription = cleanDescription.replace(
                new RegExp(val.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
                ''
              );
            });
            cleanDescription = cleanDescription.trim().replace(/[~¬ß]/g, '').replace(/\s+/g, ' ');

            let debit = 0,
              credit = 0,
              balance = 0;

            // Enhanced transaction classification
            if (cleanDescription.toUpperCase().includes('OPENING BALANCE') && numbers.length > 0) {
              balance = numbers[0];
            } else if (numbers.length >= 2) {
              // Better logic for identifying debit vs credit vs balance
              const amount = numbers[0];
              balance = numbers[numbers.length - 1]; // Last number is usually balance

              // Check if this is a credit transaction
              const isCredit =
                creditKeywords.some((kw) => cleanDescription.toUpperCase().includes(kw)) ||
                fullDescription.toUpperCase().includes('DEPOSIT') ||
                fullDescription.toUpperCase().includes('CREDIT') ||
                fullDescription.toUpperCase().includes('FROM') ||
                fullDescription.toUpperCase().includes('INTEREST');

              // Check if parentheses indicate debit
              const hasParentheses = fullDescription.includes('(') && fullDescription.includes(')');

              if (isCredit && !hasParentheses) {
                credit = amount;
              } else {
                debit = amount;
              }
            } else if (numbers.length === 1) {
              balance = numbers[0];
            } else {
              console.log('‚ö†Ô∏è NO NUMBERS FOUND - SKIPPING TRANSACTION');
              continue;
            }

            // Enhanced date parsing
            let dateStr = dateMatch[1].replace(/,/g, '/');
            if (dateStr.match(/\d{1,2}[.,\/]\d{1,2}[.,\/]\d{2}$/)) {
              const parts = dateStr.split(/[.,\/]/);
              const year = parseInt(parts[2]);
              parts[2] = year < 50 ? `20${year}` : `19${year}`;
              dateStr = parts.join('/');
            }

            const date = new Date(dateStr);
            if (isNaN(date.getTime())) {
              console.log('‚ùå INVALID DATE - SKIPPING:', dateStr);
              continue;
            }

            const year = date.getFullYear();
            const month = monthNames[date.getMonth()];

            if (!yearlyData[year]) yearlyData[year] = {};
            if (!yearlyData[year][month]) {
              yearlyData[year][month] = { transactions: [], highBalance: -Infinity, lowBalance: Infinity };
            }

            const transaction = {
              date: date,
              description: cleanDescription,
              debit,
              credit,
              balance,
            };

            // Enhanced validation with categorized warnings
            const warnings = [];
            const parsingErrors = []; // Data validation issues
            const ocrUncertainty = []; // Low confidence OCR issues

            // Check for large amounts (parsing error - data validation)
            const totalAmount = debit + credit;
            if (totalAmount > 10000) {
              parsingErrors.push(`Large amount: $${totalAmount.toFixed(2)} - check for missing decimal`);
            }

            // Check for decimal issues (parsing error - formatting issue)
            if (totalAmount > 0) {
              const amountStr = totalAmount.toString();
              if (amountStr.length > 4 && !amountStr.includes('.') && totalAmount % 1 === 0) {
                const possibleDecimal = totalAmount / 100;
                if (possibleDecimal < 10000 && possibleDecimal > 0.01) {
                  parsingErrors.push(
                    `Missing decimal? Amount: $${totalAmount} might be $${possibleDecimal.toFixed(2)}`
                  );
                }
              }
            }

            const previousBalance =
              allTransactions.length > 0 ? allTransactions[allTransactions.length - 1].balance : null;

            if (previousBalance !== null && allTransactions.length > 0) {
              const expectedBalance = previousBalance + credit - debit;
              const balanceDiff = Math.abs(expectedBalance - balance);

              // Only flag if difference is more than $1.00 or more than 10% of transaction amount
              const significantError = balanceDiff > 1.0 || (totalAmount > 0 && balanceDiff > totalAmount * 0.1);

              if (significantError) {
                parsingErrors.push(
                  `Possible balance error: Expected $${expectedBalance.toFixed(2)}, got $${balance.toFixed(2)}`
                );
              }
            }

            // Description validation (OCR uncertainty - text recognition issues)
            if (cleanDescription.length < 3) {
              ocrUncertainty.push('Description too short - possible OCR error');
            }

            // Suspicious characters (OCR uncertainty - text recognition issues)
            if (/[~¬ß¬•¬£‚Ç¨@#%^&*|\\`]/.test(cleanDescription)) {
              ocrUncertainty.push('Unusual characters detected - possible OCR error');
            }

            // Missing amounts (parsing error - data validation)
            if (
              debit === 0 &&
              credit === 0 &&
              !cleanDescription.toUpperCase().includes('OPENING BALANCE') &&
              !cleanDescription.toUpperCase().includes('BALANCE') &&
              !cleanDescription.toUpperCase().includes('FORWARD')
            ) {
              parsingErrors.push('No debit or credit amount found');
            }

            // Combine warnings for legacy compatibility
            warnings.push(...parsingErrors, ...ocrUncertainty);

            if (warnings.length > 0) {
              transaction.warnings = warnings;
              transaction.parsingErrors = parsingErrors;
              transaction.ocrUncertainty = ocrUncertainty;
              transaction.hasWarnings = true;
              transaction.hasParsingErrors = parsingErrors.length > 0;
              transaction.hasOcrUncertainty = ocrUncertainty.length > 0;
            }

            yearlyData[year][month].transactions.push(transaction);
            allTransactions.push(transaction);

            if (balance > yearlyData[year][month].highBalance) yearlyData[year][month].highBalance = balance;
            if (balance < yearlyData[year][month].lowBalance) yearlyData[year][month].lowBalance = balance;

            i = nextIndex - 1;
          }
        }

        // Generate final result
        const result = Object.keys(yearlyData)
          .sort()
          .map((year) => ({
            year: parseInt(year),
            months: Object.keys(yearlyData[year]).map((month) => ({
              month: month,
              ...yearlyData[year][month],
            })),
          }));

        // Enhanced summary logging with categorized warnings
        let totalTransactions = 0;
        let totalWarnings = 0;
        let totalParsingErrors = 0;
        let totalOcrUncertainty = 0;
        const warningBreakdown = {};
        const parsingErrorBreakdown = {};
        const ocrUncertaintyBreakdown = {};

        result.forEach((yearData) => {
          yearData.months.forEach((monthData) => {
            totalTransactions += monthData.transactions.length;
            monthData.transactions.forEach((transaction) => {
              if (transaction.hasWarnings) {
                totalWarnings++;

                // Track parsing errors (‚ùå)
                if (transaction.hasParsingErrors) {
                  totalParsingErrors++;
                  transaction.parsingErrors.forEach((error) => {
                    const errorType = error.split(':')[0];
                    parsingErrorBreakdown[errorType] = (parsingErrorBreakdown[errorType] || 0) + 1;
                  });
                }

                // Track OCR uncertainty (üîç)
                if (transaction.hasOcrUncertainty) {
                  totalOcrUncertainty++;
                  transaction.ocrUncertainty.forEach((uncertainty) => {
                    const uncertaintyType = uncertainty.split(':')[0];
                    ocrUncertaintyBreakdown[uncertaintyType] = (ocrUncertaintyBreakdown[uncertaintyType] || 0) + 1;
                  });
                }

                // Legacy warning breakdown
                transaction.warnings.forEach((warning) => {
                  const warningType = warning.split(':')[0];
                  warningBreakdown[warningType] = (warningBreakdown[warningType] || 0) + 1;
                });
              }
            });
          });
        });

        console.log('üìä ENHANCED PARSING SUMMARY:');
        console.log(`  üìù Total transactions parsed: ${totalTransactions}`);
        console.log(`  ‚ö†Ô∏è Total transactions with warnings: ${totalWarnings}`);
        console.log(`  ‚ùå Parsing errors (data validation): ${totalParsingErrors}`);
        console.log(`  üîç OCR uncertainty (text recognition): ${totalOcrUncertainty}`);
        console.log(`  üìà Warning rate: ${((totalWarnings / totalTransactions) * 100).toFixed(1)}%`);
        console.log('  üîç Parsing error breakdown:', parsingErrorBreakdown);
        console.log('  üîç OCR uncertainty breakdown:', ocrUncertaintyBreakdown);

        return result;
      }

      // React Components
      function FileUpload({ onProcess, isLoading, progressMessage, rawText, ocrStatus }) {
        const [copyButtonText, setCopyButtonText] = React.useState('Copy Raw Text');

        const handleFileChange = (event) => {
          const file = event.target.files[0];
          if (file) {
            onProcess(file);
          }
          event.target.value = null;
        };

        const handleCopy = () => {
          navigator.clipboard.writeText(rawText).then(() => {
            setCopyButtonText('Copied!');
            setTimeout(() => setCopyButtonText('Copy Raw Text'), 2000);
          });
        };

        return React.createElement(
          'div',
          {
            style: { marginBottom: '1.5em', padding: '1em', border: '1px dashed #ccc', borderRadius: '8px' },
          },
          [
            React.createElement('h3', { style: { marginTop: 0 }, key: 'header' }, [
              'Upload Statement',
              ocrStatus &&
                React.createElement(
                  'span',
                  {
                    className: `ocr-status ${ocrStatus === 'enhanced' ? 'ocr-enhanced' : 'ocr-fallback'}`,
                    key: 'status',
                  },
                  ocrStatus === 'enhanced' ? 'üî¨ Enhanced OCR' : '‚ö° Standard OCR'
                ),
            ]),
            React.createElement('input', {
              type: 'file',
              accept: '.pdf',
              onChange: handleFileChange,
              disabled: isLoading,
              key: 'input',
            }),
            isLoading &&
              React.createElement(
                'div',
                { style: { marginTop: '1em' }, key: 'loading' },
                React.createElement('p', null, [
                  React.createElement('strong', { key: 'label' }, 'Processing...'),
                  ' ' + progressMessage,
                ])
              ),
            !isLoading &&
              rawText &&
              React.createElement(
                'div',
                { style: { marginTop: '1em' }, key: 'copy' },
                React.createElement(
                  'button',
                  {
                    onClick: handleCopy,
                    style: {
                      padding: '8px 12px',
                      border: '1px solid #007bff',
                      background: '#e7f3ff',
                      borderRadius: '4px',
                      cursor: 'pointer',
                    },
                  },
                  copyButtonText
                )
              ),
          ]
        );
      }

      function StatementDisplay({ data }) {
        const [sortConfig, setSortConfig] = React.useState({ key: null, direction: 'asc' });
        const [filterType, setFilterType] = React.useState('all');

        if (!data || data.length === 0) {
          return React.createElement('p', null, 'Upload a statement to see the data.');
        }

        const handleSort = (key) => {
          let direction = 'asc';
          if (sortConfig.key === key && sortConfig.direction === 'asc') {
            direction = 'desc';
          }
          setSortConfig({ key, direction });
        };

        const getSortIndicator = (key) => {
          if (sortConfig.key === key) {
            return sortConfig.direction === 'asc' ? '‚Üë' : '‚Üì';
          }
          return '';
        };

        const sortTransactions = (transactions) => {
          if (!sortConfig.key) return transactions;

          return [...transactions].sort((a, b) => {
            let aVal = a[sortConfig.key];
            let bVal = b[sortConfig.key];

            if (sortConfig.key === 'description') {
              aVal = aVal.toLowerCase();
              bVal = bVal.toLowerCase();
            } else if (sortConfig.key === 'date') {
              aVal = aVal ? aVal.getTime() : 0;
              bVal = bVal ? bVal.getTime() : 0;
            }

            if (aVal < bVal) return sortConfig.direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return sortConfig.direction === 'asc' ? 1 : -1;
            return 0;
          });
        };

        const filterTransactions = (transactions) => {
          if (filterType === 'all') return transactions;
          if (filterType === 'credit') return transactions.filter((t) => t.credit > 0);
          if (filterType === 'debit') return transactions.filter((t) => t.debit > 0);
          if (filterType === 'warnings') return transactions.filter((t) => t.hasWarnings);
          return transactions;
        };

        return React.createElement(
          'div',
          { className: 'page-grid' },
          data.flatMap((yearData) =>
            yearData.months.map((monthData) => {
              const processedTransactions = filterTransactions(sortTransactions(monthData.transactions));

              return React.createElement(
                'div',
                {
                  key: `${yearData.year}-${monthData.month}`,
                  className: 'month-card',
                },
                [
                  React.createElement('div', { className: 'month-header', key: 'header' }, [
                    React.createElement('span', { className: 'year-label', key: 'year' }, yearData.year),
                    React.createElement('span', { className: 'month-label', key: 'month' }, monthData.month),
                    React.createElement(
                      'div',
                      { className: 'filter-controls', key: 'controls' },
                      React.createElement(
                        'select',
                        {
                          className: 'filter-select',
                          value: filterType,
                          onChange: (e) => setFilterType(e.target.value),
                        },
                        [
                          React.createElement('option', { value: 'all', key: 'all' }, 'All Transactions'),
                          React.createElement('option', { value: 'credit', key: 'credit' }, 'Credits Only'),
                          React.createElement('option', { value: 'debit', key: 'debit' }, 'Debits Only'),
                          React.createElement('option', { value: 'warnings', key: 'warnings' }, 'Warnings Only'),
                        ]
                      )
                    ),
                  ]),
                  React.createElement('div', { className: 'transactions-column', key: 'transactions' }, [
                    React.createElement('div', { className: 'transaction-header', key: 'header' }, [
                      React.createElement(
                        'div',
                        {
                          className: 'transaction-date',
                          onClick: () => handleSort('date'),
                          key: 'date',
                        },
                        ['Date', React.createElement('span', { className: 'sort-indicator' }, getSortIndicator('date'))]
                      ),
                      React.createElement(
                        'div',
                        {
                          className: 'transaction-description',
                          onClick: () => handleSort('description'),
                          key: 'description',
                        },
                        [
                          'Description',
                          React.createElement('span', { className: 'sort-indicator' }, getSortIndicator('description')),
                        ]
                      ),
                      React.createElement(
                        'div',
                        {
                          onClick: () => handleSort('debit'),
                          key: 'debit',
                        },
                        [
                          'Debit',
                          React.createElement('span', { className: 'sort-indicator' }, getSortIndicator('debit')),
                        ]
                      ),
                      React.createElement(
                        'div',
                        {
                          onClick: () => handleSort('credit'),
                          key: 'credit',
                        },
                        [
                          'Credit',
                          React.createElement('span', { className: 'sort-indicator' }, getSortIndicator('credit')),
                        ]
                      ),
                      React.createElement(
                        'div',
                        {
                          onClick: () => handleSort('balance'),
                          key: 'balance',
                        },
                        [
                          'Balance',
                          React.createElement('span', { className: 'sort-indicator' }, getSortIndicator('balance')),
                        ]
                      ),
                    ]),
                    // Warning Legend
                    React.createElement('div', { className: 'warning-legend', key: 'legend' }, [
                      React.createElement('span', { key: 'label' }, 'Warning Icons:'),
                      React.createElement('div', { className: 'legend-item', key: 'parsing' }, [
                        React.createElement('span', { className: 'legend-icon', key: 'icon' }, '‚ùå'),
                        React.createElement('span', { key: 'text' }, 'Parsing Error'),
                      ]),
                      React.createElement('div', { className: 'legend-item', key: 'ocr' }, [
                        React.createElement('span', { className: 'legend-icon', key: 'icon' }, 'üîç'),
                        React.createElement('span', { key: 'text' }, 'OCR Uncertainty'),
                      ]),
                    ]),
                    ...processedTransactions.map((trans, index) =>
                      React.createElement(
                        'div',
                        {
                          key: index,
                          className: `transaction-row ${
                            trans.hasParsingErrors
                              ? 'parsing-error-row'
                              : trans.hasOcrUncertainty
                                ? 'ocr-uncertainty-row'
                                : trans.hasWarnings
                                  ? 'warning-row'
                                  : ''
                          }`,
                        },
                        [
                          React.createElement(
                            'div',
                            { className: 'transaction-date', key: 'date' },
                            trans.date
                              ? trans.date.toLocaleDateString('en-US', {
                                  month: '2-digit',
                                  day: '2-digit',
                                  year: '2-digit',
                                })
                              : '-'
                          ),
                          React.createElement('div', { className: 'transaction-description', key: 'description' }, [
                            trans.description,
                            // Show parsing errors with red exclamation
                            trans.hasParsingErrors &&
                              React.createElement(
                                'span',
                                {
                                  className: 'parsing-error warning-tooltip',
                                  title: `Parsing Error: ${trans.parsingErrors.join('; ')}`,
                                  key: 'parsing-error',
                                },
                                '‚ùå'
                              ),
                            // Show OCR uncertainty with yellow warning
                            trans.hasOcrUncertainty &&
                              React.createElement(
                                'span',
                                {
                                  className: 'ocr-uncertainty warning-tooltip',
                                  title: `OCR Uncertainty: ${trans.ocrUncertainty.join('; ')}`,
                                  key: 'ocr-uncertainty',
                                },
                                'üîç'
                              ),
                          ]),
                          React.createElement(
                            'div',
                            { className: 'debit', key: 'debit' },
                            trans.debit > 0 ? `($${trans.debit.toFixed(2)})` : '-'
                          ),
                          React.createElement(
                            'div',
                            { className: 'credit', key: 'credit' },
                            trans.credit > 0 ? `$${trans.credit.toFixed(2)}` : '-'
                          ),
                          React.createElement(
                            'div',
                            { className: 'balance', key: 'balance' },
                            `$${trans.balance.toFixed(2)}`
                          ),
                        ]
                      )
                    ),
                    React.createElement('div', { className: 'balance-summary', key: 'summary' }, [
                      React.createElement('div', { key: 'high' }, [
                        'High: ',
                        React.createElement('span', { className: 'balance' }, `$${monthData.highBalance.toFixed(2)}`),
                      ]),
                      React.createElement('div', { key: 'low' }, [
                        'Low: ',
                        React.createElement('span', { className: 'balance' }, `$${monthData.lowBalance.toFixed(2)}`),
                      ]),
                      React.createElement(
                        'div',
                        { key: 'showing' },
                        `Showing: ${processedTransactions.length} of ${monthData.transactions.length}`
                      ),
                      React.createElement(
                        'div',
                        { key: 'warnings' },
                        `Warnings: ${monthData.transactions.filter((t) => t.hasWarnings).length}`
                      ),
                    ]),
                  ]),
                ]
              );
            })
          )
        );
      }

      // Main App Component
      function App() {
        const [statementData, setStatementData] = React.useState([]);
        const [isLoading, setIsLoading] = React.useState(false);
        const [progressMessage, setProgressMessage] = React.useState('');
        const [rawOcrText, setRawOcrText] = React.useState('');
        const [ocrStatus, setOcrStatus] = React.useState(null);

        const handleFileProcess = async (file) => {
          setIsLoading(true);
          setProgressMessage('Reading file...');
          setStatementData([]);
          setRawOcrText('');
          setOcrStatus('enhanced');

          try {
            const fileReader = new FileReader();
            fileReader.readAsArrayBuffer(file);
            fileReader.onload = async (e) => {
              const typedarray = new Uint8Array(e.target.result);
              const pdf = await pdfjsLib.getDocument(typedarray).promise;
              let fullText = '';

              for (let i = 1; i <= pdf.numPages; i++) {
                setProgressMessage(`Enhanced OCR processing on page ${i} of ${pdf.numPages}...`);

                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 3.0 }); // Higher scale for better accuracy
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                await page.render({ canvasContext: context, viewport: viewport }).promise;

                // Use enhanced OCR processing
                const pageText = await enhancedOCRProcessing(canvas);
                fullText += pageText + '\n';

                console.log(`üìä Page ${i} processed - text length: ${pageText.length}`);
              }

              setRawOcrText(fullText);
              setProgressMessage('Parsing extracted text with enhanced validation...');

              // Use enhanced parsing
              const parsedData = parseStatementTextEnhanced(fullText);
              setStatementData(parsedData);
              setProgressMessage('Enhanced processing complete!');
              setIsLoading(false);
            };
          } catch (error) {
            console.error('Error processing PDF with enhanced OCR:', error);
            setProgressMessage('Processing failed. Check console for details.');
            setOcrStatus('fallback');
            setIsLoading(false);
          }
        };

        return React.createElement('div', null, [
          React.createElement(FileUpload, {
            onProcess: handleFileProcess,
            isLoading: isLoading,
            progressMessage: progressMessage,
            rawText: rawOcrText,
            ocrStatus: ocrStatus,
            key: 'upload',
          }),
          React.createElement(StatementDisplay, {
            data: statementData,
            key: 'display',
          }),
        ]);
      }

      // Initialize the app after DOM is ready
      document.addEventListener('DOMContentLoaded', function () {
        const container = document.getElementById('root');
        if (container) {
          const root = ReactDOM.createRoot(container);
          root.render(React.createElement(App));
        } else {
          console.error('Root container not found!');
        }
      });
    </script>
  </head>
  <body>
    <h1>Bank Statement Review Tool - Enhanced</h1>
    <div id="root"></div>
  </body>
</html>
