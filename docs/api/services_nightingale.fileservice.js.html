<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/nightingale.fileservice.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/nightingale.fileservice.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Uses global window.dateUtils instead of ES6 import

/**
 * Nightingale Application Suite - Shared File System Service
 *
 * This file contains the standardized, modular FileSystemService class for handling
 * all file and directory operations using the File System Access API.
 * It uses dependency injection to remain self-contained and reusable.
 */
class FileSystemService {
  constructor({
    fileName = 'nightingale-data.json',
    errorCallback = console.error,
    sanitizeFn = (str) => str,
    tabId,
    dbKey = 'nightingaleDirectory',
  }) {
    this.directoryHandle = null;
    this.fileName = fileName;
    this.errorCallback = errorCallback;
    this.sanitizeFn = sanitizeFn;
    this.tabId = tabId;
    this.dbName = 'NightingaleFileAccess';
    this.storeName = 'directoryHandles';
    this.dbKey = dbKey;
  }

  isSupported() {
    return 'showDirectoryPicker' in window;
  }

  async connect() {
    if (!this.isSupported()) {
      this.errorCallback(
        'File System Access API is not supported in this browser.',
        'error'
      );
      return false;
    }
    try {
      this.directoryHandle = await window.showDirectoryPicker();
      const permissionGranted = await this.requestPermission();
      if (permissionGranted) {
        await this.storeDirectoryHandle();
      }
      return permissionGranted;
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Error selecting directory:', err);
      }
      return false;
    }
  }

  async checkPermission() {
    if (!this.directoryHandle) return 'prompt';
    return await this.directoryHandle.queryPermission({ mode: 'readwrite' });
  }

  async requestPermission() {
    if (!this.directoryHandle) return false;
    if (
      (await this.directoryHandle.requestPermission({ mode: 'readwrite' })) ===
      'granted'
    ) {
      return true;
    }
    this.errorCallback('Permission denied for the stored directory.', 'error');
    return false;
  }

  async writeFile(data) {
    if (!this.directoryHandle || (await this.checkPermission()) !== 'granted') {
      this.errorCallback(
        'Cannot write file: No directory selected or permission not granted.',
        'error'
      );
      return false;
    }
    try {
      const fileHandleWrite = await this.directoryHandle.getFileHandle(
        this.fileName,
        { create: true }
      );
      const writable = await fileHandleWrite.createWritable();
      await writable.write(JSON.stringify(data, null, 2));
      await writable.close();
      localStorage.setItem(
        'nightingale-last-save',
        JSON.stringify({
          timestamp: window.dateUtils.now(),
          tabId: this.tabId,
        })
      );
      return true;
    } catch (err) {
      this.errorCallback(
        `Error writing file "${this.fileName}": ${err.message}`,
        'error'
      );
      return false;
    }
  }

  async writeTextFileToSubdirectory(subdirectoryName, fileName, data) {
    if (!this.directoryHandle || (await this.checkPermission()) !== 'granted') {
      this.errorCallback('Cannot save file: No directory connected.', 'error');
      return false;
    }
    try {
      const dirHandle = await this.directoryHandle.getDirectoryHandle(
        subdirectoryName,
        { create: true }
      );
      const fileHandle = await dirHandle.getFileHandle(fileName, {
        create: true,
      });
      const writable = await fileHandle.createWritable();
      await writable.write(data);
      await writable.close();
      return true;
    } catch (err) {
      this.errorCallback(`Error saving file: ${err.message}`, 'error');
      return false;
    }
  }

  async readFile() {
    if (!this.directoryHandle || (await this.checkPermission()) !== 'granted') {
      this.errorCallback(
        'Cannot read file: No directory selected or permission not granted.',
        'error'
      );
      return null;
    }
    try {
      const fileHandle = await this.directoryHandle.getFileHandle(
        this.fileName
      );
      const file = await fileHandle.getFile();
      const contents = await file.text();
      return JSON.parse(contents);
    } catch (err) {
      if (err.name === 'NotFoundError') {
        console.log(
          `File "${this.fileName}" not found. A new one will be created on the first save.`
        );
        return null;
      } else {
        this.errorCallback(
          `Error reading file "${this.fileName}": ${err.message}`,
          'error'
        );
        throw err;
      }
    }
  }

  async restoreLastDirectoryAccess() {
    if (!this.isSupported()) {
      return { handle: null, permission: 'unsupported' };
    }
    try {
      const handle = await this.getStoredDirectoryHandle();
      if (handle) {
        this.directoryHandle = handle;
        const permission = await this.checkPermission();
        return { handle, permission };
      }
    } catch (error) {
      console.error('Error restoring directory access:', error);
      await this.clearStoredDirectoryHandle();
    }
    return { handle: null, permission: 'prompt' };
  }

  async getStoredDirectoryHandle() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          resolve(null);
          return;
        }
        const getRequest = db
          .transaction(this.storeName)
          .objectStore(this.storeName)
          .get(this.dbKey);
        getRequest.onsuccess = () => resolve(getRequest.result?.handle || null);
        getRequest.onerror = () => resolve(null);
      };
      request.onupgradeneeded = (e) => {
        e.target.result.createObjectStore(this.storeName);
      };
    });
  }

  async storeDirectoryHandle() {
    if (!this.directoryHandle) return;
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onerror = (e) => reject(e);
      request.onsuccess = () => {
        const db = request.result;
        const putRequest = db
          .transaction(this.storeName, 'readwrite')
          .objectStore(this.storeName)
          .put({ handle: this.directoryHandle }, this.dbKey);
        putRequest.onsuccess = () => resolve();
        putRequest.onerror = (e) => reject(e);
      };
    });
  }

  async clearStoredDirectoryHandle() {
    return new Promise((resolve) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onsuccess = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          resolve();
          return;
        }
        const deleteRequest = db
          .transaction(this.storeName, 'readwrite')
          .objectStore(this.storeName)
          .delete(this.dbKey);
        deleteRequest.onsuccess = () => resolve();
        deleteRequest.onerror = () => resolve();
      };
      request.onerror = () => resolve();
    });
  }

  async openLocalFile(filePath) {
    if (!this.directoryHandle || (await this.checkPermission()) !== 'granted') {
      this.errorCallback(
        'Cannot open file: No directory selected or permission denied.',
        'error'
      );
      return false;
    }
    try {
      const pathParts = filePath.replace(/\\/g, '/').split('/');
      const fileName = pathParts.pop();
      let currentDirectoryHandle = this.directoryHandle;
      for (const part of pathParts) {
        if (part) {
          currentDirectoryHandle =
            await currentDirectoryHandle.getDirectoryHandle(part);
        }
      }
      const fileHandle = await currentDirectoryHandle.getFileHandle(fileName);
      const file = await fileHandle.getFile();
      const url = URL.createObjectURL(file);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      return true;
    } catch (err) {
      if (err.name === 'NotFoundError') {
        this.errorCallback(
          `File not found: Make sure "${this.sanitizeFn(filePath)}" is in your data directory.`,
          'error'
        );
      } else {
        this.errorCallback(`Error opening file: ${err.message}`, 'error');
      }
      return false;
    }
  }
}

// Make FileSystemService available globally
window.FileSystemService = FileSystemService;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="FileSystemService.html">FileSystemService</a></li><li><a href="NightingaleSearchService.html">NightingaleSearchService</a></li><li><a href="ToastQueue.html">ToastQueue</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Badge">Badge</a></li><li><a href="global.html#Button">Button</a></li><li><a href="global.html#Card">Card</a></li><li><a href="global.html#CardActions">CardActions</a></li><li><a href="global.html#CardField">CardField</a></li><li><a href="global.html#CardGrid">CardGrid</a></li><li><a href="global.html#CardList">CardList</a></li><li><a href="global.html#Checkbox">Checkbox</a></li><li><a href="global.html#ConfirmationModal">ConfirmationModal</a></li><li><a href="global.html#CountBadge">CountBadge</a></li><li><a href="global.html#DataTable">DataTable</a></li><li><a href="global.html#DateInput">DateInput</a></li><li><a href="global.html#FinancialItemCard">FinancialItemCard</a></li><li><a href="global.html#FinancialItemGrid">FinancialItemGrid</a></li><li><a href="global.html#FinancialItemList">FinancialItemList</a></li><li><a href="global.html#FormField">FormField</a></li><li><a href="global.html#FormModal">FormModal</a></li><li><a href="global.html#Modal">Modal</a></li><li><a href="global.html#MultiBadge">MultiBadge</a></li><li><a href="global.html#NotesModal">NotesModal</a></li><li><a href="global.html#PersonCreationModal">PersonCreationModal</a></li><li><a href="global.html#ProgressBadge">ProgressBadge</a></li><li><a href="global.html#SearchBar">SearchBar</a></li><li><a href="global.html#Select">Select</a></li><li><a href="global.html#StepperModal">StepperModal</a></li><li><a href="global.html#TOAST_CONFIG">TOAST_CONFIG</a></li><li><a href="global.html#TextInput">TextInput</a></li><li><a href="global.html#Textarea">Textarea</a></li><li><a href="global.html#Validators">Validators</a></li><li><a href="global.html#clearAllToasts">clearAllToasts</a></li><li><a href="global.html#encodeURL">encodeURL</a></li><li><a href="global.html#formatDate">formatDate</a></li><li><a href="global.html#formatPersonName">formatPersonName</a></li><li><a href="global.html#formatPhoneNumber">formatPhoneNumber</a></li><li><a href="global.html#formatProperCase">formatProperCase</a></li><li><a href="global.html#getActiveToastCount">getActiveToastCount</a></li><li><a href="global.html#getAppDateLabel">getAppDateLabel</a></li><li><a href="global.html#getDefaultAppDetails">getDefaultAppDetails</a></li><li><a href="global.html#getFlatFinancials">getFlatFinancials</a></li><li><a href="global.html#getNextId">getNextId</a></li><li><a href="global.html#getUniqueNoteCategories">getUniqueNoteCategories</a></li><li><a href="global.html#initializeToastSystem">initializeToastSystem</a></li><li><a href="global.html#loadBusinessComponents">loadBusinessComponents</a></li><li><a href="global.html#loadComponentLayers">loadComponentLayers</a></li><li><a href="global.html#loadUIComponents">loadUIComponents</a></li><li><a href="global.html#parseAvsAccountBlock">parseAvsAccountBlock</a></li><li><a href="global.html#parseAvsData">parseAvsData</a></li><li><a href="global.html#sanitize">sanitize</a></li><li><a href="global.html#sanitizeHTML">sanitizeHTML</a></li><li><a href="global.html#setSanitizedInnerHTML">setSanitizedInnerHTML</a></li><li><a href="global.html#showSuccessToast">showSuccessToast</a></li><li><a href="global.html#showToast">showToast</a></li><li><a href="global.html#toInputDateFormat">toInputDateFormat</a></li><li><a href="global.html#updateToastConfig">updateToastConfig</a></li><li><a href="global.html#waitForUIComponents">waitForUIComponents</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Aug 20 2025 13:57:37 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
